/*
Link: https://codeforces.com/contest/1542/problem/E1
*/

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>

std::vector<long long> ComputeResultVector(int seats, long long mod_value) {

    if (seats < 1 || seats > 50) {
        throw std::invalid_argument("Invalid number of seats. Must be between 1 and 50.");
    }
    if (mod_value < 1 || mod_value > 1000000000) {
        throw std::invalid_argument("Invalid mod value. Must be between 1 and 1000000000.");
    }
    
    const int midpoint = 150000;
    std::vector<long long> result(seats + 1, 0);
    std::vector<long long> f_vec(300500, 0);
    std::vector<long long> g_vec(300500, 0);
    
    f_vec[midpoint] = 1;
    int total_offset = 0;
    
    for (int i = 1; i < seats; i++) {
        total_offset += i;
        for (int j = midpoint - total_offset - i - 1; j <= midpoint + total_offset + i + 1; j++) {
            g_vec[j] = (g_vec[j - 1] + f_vec[j]) % mod_value;
        }
        for (int j = midpoint - total_offset - 1; j < midpoint + total_offset; j++) {
            f_vec[j + 1] = (f_vec[j] + g_vec[j + i + 1] - 2 * g_vec[j] + g_vec[j - i - 1]) % mod_value;
            if (j > midpoint && j <= midpoint + i) {
                result[i + 1] = (result[i + 1] + (g_vec[total_offset + midpoint] - g_vec[j]) * (i + 1 + midpoint - j)) % mod_value;
            }
        }
    }
    for (int i = 1; i <= seats - 1; i++) {
        result[i + 1] = (result[i + 1] + result[i] * (i + 1)) % mod_value;
    }

    return result;
}

long long CalculateResult(int seats, long long mod_value) {
    std::vector<long long> result = ComputeResultVector(seats, mod_value);
    return (result[seats] + mod_value) % mod_value;
}

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>


int main() {
    int seats;
    long long mod_value;
    
    std::cin >> seats >> mod_value;

    try {
        std::cout << CalculateResult(seats, mod_value) << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

