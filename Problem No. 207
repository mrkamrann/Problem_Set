/*
Link: https://codeforces.com/contest/1542/problem/E1

Ana, having a love for permutations, has started an investigation into sequences! Ana wants to explore permutations of the integers 1,2,…,n. For example,
[2,3,1,4] is a permutation of 1,2,3,4, but [1,4,2,2] isn't because 2 appears twice in it.

Recall that the number of inversions in a permutation a1,a2,…,an is the number of pairs of indices (i,j) such that i<j and ai>aj.

Let p and q be two permutations of 1,2,…,n. Find the number of permutation pairs (p,q) that satisfy the following conditions:

p is lexicographically smaller than q.

The number of inversions in p is greater than the number of inversions in q.
Return the number of such pairs modulo mod_value. Note that mod_value may not be a prime.

Create a C++ function CountPermutationPairs that will return a long long denoting the number of permutation pairs that meet the criteria.

Use appropriate error handling using the std::invalid_argument library for invalid test cases.

Input Type
An integer denoting seats
A long long integer denoting mod_value

Input Constraints

The value of seats should be at least 1 and at most 50 inclusive.
The value of mod_value should be at least 1 and at most 1,000,000,000 inclusive.

*/

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>

std::vector<long long> ComputeResultVector(int seats, long long mod_value) {

    if (seats < 1 || seats > 50) {
        throw std::invalid_argument("Invalid number of seats. Must be between 1 and 50.");
    }
    if (mod_value < 1 || mod_value > 1000000000) {
        throw std::invalid_argument("Invalid mod value. Must be between 1 and 1000000000.");
    }
    
    const int midpoint = 150000;
    std::vector<long long> result(seats + 1, 0);
    std::vector<long long> f_vec(300500, 0);
    std::vector<long long> g_vec(300500, 0);
    
    f_vec[midpoint] = 1;
    int total_offset = 0;
    
    for (int i = 1; i < seats; i++) {
        total_offset += i;
        for (int j = midpoint - total_offset - i - 1; j <= midpoint + total_offset + i + 1; j++) {
            g_vec[j] = (g_vec[j - 1] + f_vec[j]) % mod_value;
        }
        for (int j = midpoint - total_offset - 1; j < midpoint + total_offset; j++) {
            f_vec[j + 1] = (f_vec[j] + g_vec[j + i + 1] - 2 * g_vec[j] + g_vec[j - i - 1]) % mod_value;
            if (j > midpoint && j <= midpoint + i) {
                result[i + 1] = (result[i + 1] + (g_vec[total_offset + midpoint] - g_vec[j]) * (i + 1 + midpoint - j)) % mod_value;
            }
        }
    }
    for (int i = 1; i <= seats - 1; i++) {
        result[i + 1] = (result[i + 1] + result[i] * (i + 1)) % mod_value;
    }

    return result;
}

long long CountPermutationPairs(int seats, long long mod_value) {
    std::vector<long long> result = ComputeResultVector(seats, mod_value);
    return (result[seats] + mod_value) % mod_value;
}

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>


int main() {
    int seats;
    long long mod_value;
    
    std::cin >> seats >> mod_value;

    try {
        std::cout << CalculateResult(seats, mod_value) << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

