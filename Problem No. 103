/*
Link : https://codeforces.com/contest/95/problem/D

Julie likes horse racing very much. Horses numbered from start_range to end_range take part in the races. Julie wants to evaluate the probability of victory; 
for some reason, to do that she needs to know the amount of nearly lucky horses' numbers. A nearly lucky number is an integer number that has at least two lucky 
digits, the distance between which does not exceed max_k. Julie learned from some of her mates from Lviv that lucky digits are digits 4 and 7. The distance between
the digits is the absolute difference between their positions in the number of a horse. For example, if max_k = 2, then numbers 412395497, 404, 4070400000070004007
are nearly lucky and numbers 4, 4123954997, 4007000040070004007 are not.

Julie prepared len queries [start_range, end_range] and invented number max_k, common for all of them. Your task is to find how many nearly happy numbers
there are in each of these segments. Since the answers can be quite large, output them modulo 1000000007 (10^9 + 7).

Create a C++ function DetermineNearlyLuckyNumbers that will return a vector of integers denoting the answers for each query.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An Integer denoting max_k;
vector<vector<string>> denoting queries;

Input Constraints:

The length of queries(len) should be at least 1 and at most 1000 inclusive.
Each queries's first value(start_range) should be in the range [1, 10^1000] inclusive.
Each queries's second value(end_range) should be in the range [1, 10^1000] inclusive and should be greater than or equal to the first value.
Both start_range and end_range should not contain any leading zeroes
The value of max_k should be in the range [1, 1000] inclusive.

*/

#include <cassert>
#include <cstring>
#include <stdexcept>
#include <vector>
#include <iostream>

class Solution {
private:
    static const int modulus = 1e9 + 7;
    static const int max_val = 1005;
    int dp_table[max_val][max_val][2];
    int max_digit_count;
    int max_distance;
    int len;
    std::vector<int> digits;
    std::string start_range, end_range;

    int Solve(int position, int start_pos, bool is_below, bool has_valid_segment) {
        if (position > max_digit_count) return has_valid_segment;
        if (is_below && ~dp_table[max_digit_count - position][start_pos ? position - start_pos : 0][has_valid_segment]) 
            return dp_table[max_digit_count - position][start_pos ? position - start_pos : 0][has_valid_segment];
        
        long long sum = 0;
        for (int i = is_below ? 9 : digits[position]; i >= 0; i--) {
            if (i == 4 || i == 7) {
                sum += Solve(position + 1, position, is_below || i < digits[position], has_valid_segment || start_pos && position - start_pos <= max_distance);
            } else {
                sum += Solve(position + 1, start_pos, is_below || i < digits[position], has_valid_segment);
            }
        }
        sum %= modulus;
        if (is_below) dp_table[max_digit_count - position][start_pos ? position - start_pos : 0][has_valid_segment] = sum;
        return sum;
    }

    int Initialize(const std::string& str, bool decrement) {
        max_digit_count = str.length();
        digits.resize(max_digit_count + 1);
        for (int i = 1; i <= max_digit_count; i++) {
            digits[i] = str[i - 1] - '0';
        }
        if (decrement) {
            int i = max_digit_count;
            while (i > 0 && !digits[i]) {
                digits[i] = 9;
                i--;
            }
            if (i > 0) {
                digits[i]--;
            }
        }
        return Solve(1, 0, 0, 0);
    }

public:
    std::vector<int> DetermineNearlyLuckyNumbers(int max_k, const std::vector<std::vector<std::string>>& queries) {
        if (max_k < 1 || max_k > 1000) throw std::invalid_argument("Invalid max_k");
        if (queries.size() < 1 || queries.size() > 1000) throw std::invalid_argument("Invalid number of test cases");
        
        for (const std::vector<std::string> &query : queries) {
            if (query[0].length() > 100 || query[1].length() > 100 || query[0].length() < 1 || query[1].length() < 1 || query[0][0] == '0' || query[1][0] == '0') {
                throw std::invalid_argument("Invalid range length");
            }
            
            if (query[0][0] == '0' || query[1][0] == '0') {
                throw std::invalid_argument("Ranges should not contain leading zeroes");
            }
        }
        
        len = queries.size();
        max_distance = max_k;
        memset(dp_table, -1, sizeof(dp_table));
        std::vector<int> result;

        for (const std::vector<std::string> & query : queries) {
            start_range = query[0];
            end_range = query[1];
            result.push_back((Initialize(end_range, false) - Initialize(start_range, true) + modulus) % modulus);
        }
        return result;
    }
};

int main() {
    

    return 0;
}
