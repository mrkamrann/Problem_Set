/*
Link: https://codeforces.com/contest/1651/problem/E

Andrew is studying a bipartite graph where the vertices of the first part are numbered from 1 to num_elements, and the vertices of the second part are numbered 
from num_elements+1 to 2*num_elements. Each vertex has exactly two incident edges.

For a tuple of four integers (l, r, L, R), where 1 ≤ l ≤ r ≤ num_elements and num_elements+1 ≤ L ≤ R ≤ 2*num_elements, let's define G'(l, r, L, R) as the
graph which consists of all vertices of the given graph that are included in the segment [l, r] or in the segment [L, R], and all edges of the given graph such 
that each of their endpoints belongs to one of these segments. In other words, to obtain G'(l, r, L, R) from the original graph, you have to remove all 
vertices i such that i∉[l, r] and i∉[L, R], and all edges incident to these vertices.

Calculate the sum of MM(G'(l, r, L, R)) over all tuples of integers (l, r, L, R) having 1 ≤ l ≤ r ≤ num_elements and num_elements+1 ≤ L ≤ R ≤ 2*num_elements.
Here, MM(G) denotes the size of the maximum matching in a graph G.

Given one integer num_elements  — the number of vertices in each part.
And, a 2d vector pairs of size 2*num_elements where each pairs[i] denoting an edge of the graph; 

There are no multiple edges in the given graph, and each vertex has exactly two incident edges.

Reurn one number — the sum of MM(G'(l, r, L, R)) over all tuples of integers (l, r, L, R) having 1 ≤ l ≤ r ≤ num_elements and num_elements+1 ≤ L ≤ R ≤ 2*num_elements.

Create a C++ Function CalculateSumOfMaxMatchings that will return a long long denoting the sum of MM(G'(l, r, L, R)). 

Use appropriate Error Handling using the stdexcept library for invalid test cases.

Input Type

An integer num_elements
A vector<vector<long long>> denoting pairs

Input Constraints:

The value of num_elements should be in the range [2, 1500] inclusive.
The length of pairs should be 2*num_elements.
Each value of pairs[i][0] should be in the range [1, num_elements] inclusive.
Each value of pairs[i][1] should be in the range [num_elements+1, 2*num_elements] inclusive.

*/


#include <vector>
#include <iostream>
#include <stdexcept>
#include <cassert>

int FindParent(int type, int x_coord, std::vector<int> parent[2]) {
    if (parent[type][x_coord] == x_coord) {
        return x_coord;
    } else {
        return parent[type][x_coord] = FindParent(type, parent[type][x_coord], parent);
    }
}

void ValidatePairs(const std::vector<std::vector<int>>& pairs, int num_elements) {
    std::vector<int> degree(num_elements * 2 + 1, 0);

    for (int i = 0; i < pairs.size(); ++i) {
        int x_coord = pairs[i][0];
        int y_coord  = pairs[i][1];

        if (x_coord  < 1 || x_coord  > num_elements || y_coord  < num_elements + 1 || y_coord  > num_elements * 2) {
            throw std::invalid_argument("Invalid pair values");
        }

        degree[x_coord]++;
        degree[y_coord]++;

        if (degree[x_coord] > 2 || degree[y_coord] > 2) {
            throw std::invalid_argument("Each vertex must have exactly two incident edges");
        }
    }
}

long long CalculateSumOfMaxMatchings(int num_elements, const std::vector<std::vector<int>>& pairs) {

    if (num_elements < 2 || num_elements > 1500) {
        throw std::invalid_argument("Invalid number of elements");
    }

    ValidatePairs(pairs, num_elements);

    int element_count = num_elements;
    long long answer = 0;
    std::vector<int> parent[2];
    std::vector<long long> result;
    std::vector<std::vector<int>> matches(element_count + 1);

    parent[0].resize(element_count + 1);
    parent[1].resize(element_count + 1);

    for (int i = 0; i < pairs.size(); ++i) {
        matches[pairs[i][0]].push_back(pairs[i][1] - element_count);
    }

    for (int i = 1; i <= element_count; ++i) {
        for (int j = 1; j <= element_count; ++j) {
            parent[0][j] = j;
            parent[1][j] = j;
        }
        long long res = 0;

        for (int j = i; j <= element_count; ++j) {
            int left_a = FindParent(0, matches[j][0], parent);
            int right_a = FindParent(1, matches[j][0], parent);
            int left_b = FindParent(0, matches[j][1], parent);
            int right_b = FindParent(1, matches[j][1], parent);

            res += static_cast<long long>(left_a) * (element_count + 1 - right_a) + static_cast<long long>(left_b) * (element_count + 1 - right_b);

            if (left_a > left_b) std::swap(left_a, left_b);
            if (right_a < right_b) std::swap(right_a, right_b);

            parent[0][left_b] = left_a;
            parent[1][right_b] = right_a;
            res -= static_cast<long long>(left_a) * (element_count - right_a + 1);
            answer += res;
        }
    }

   return answer;
}

#include <vector>
#include <iostream>
#include <stdexcept>
#include <cassert>

int main() {
    //TEST
    int num_elements;
    std::cin >> num_elements;
    std::vector<std::vector<int>> pairs(num_elements * 2, std::vector<int>(2));

    for (int i = 0; i < num_elements * 2; ++i) {
        int x, y;
        std::cin >> x >> y;
        pairs[i][0] = x;
        pairs[i][1] = y;
    }

    long long result = ProcessPairs(num_elements, pairs);

    std::cout << result << std::endl;
    //TEST_END

    return 0;
}
