/*
Link: https://codeforces.com/contest/1187/problem/F


Below is the rewritten problem statement with the specified changes:

Anderson has a vector of integers called vector_x where vector_x = [x_1, x_2, ..., x_n]. The task is to determine the minimal size of a partition of vector_x 
into subsegments such that all elements in each subsegment are equal. This minimal size is denoted as B(x). For example, B([3, 3, 6, 1, 6, 6, 6]) = 4 using the 
partition: [3, 3 | 6 | 1 | 6, 6, 6].

Anderson does not know the exact values of vector_x, but he knows that each x_i can be any integer value from [l_i, r_i] (where l_i ≤ r_i) uniformly at random. 
All x_i are independent of each other.

Anderson needs to calculate the expected value of (B(x))^2, denoted as E((B(x))^2). It is guaranteed that the expected value can be represented as a rational 
fraction P / Q where (P, Q) = 1. Anderson needs to print the value of P * Q^{-1} mod 10^9 + 7.

Given two vectors left_vec and right_vec both of size vec_size return the single integer — E((B(x))^2) as P * Q^{-1} mod 10^9 + 7.

Create a C++ Function CalculateExpectedB that will return an integer denoting the expected value of (B(x))^2.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type

vector<int> denoting left_vec
vector<int> denoting right_vec

Input Constraints

The length of vec_size should be at least 1 and at most 2 * 10^5 inclusive.
Both the vectors should be of equal size
Each value of left_vec should be in the range [1, 10^9] inclusive.
Each value of right_vec should be in the range [1, 10^9] inclusive.
Each left_vec[i] should be less than or equal to right_vec[i].
*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>
#include <numeric>
#include <algorithm>



int QuickPower(int base, int exponent) {
    const int modulus = 1000000007;
    int result = 1;
    for (; exponent; exponent >>= 1, base = 1LL * base * base % modulus) {
        if (exponent & 1) result = 1LL * result * base % modulus;
    }
    return result;
}


int CalculateExpectedB(const std::vector<int>& left_vec, const std::vector<int>& right_vec) {

    int vec_size = left_vec.size();

    if (vec_size <= 0 || vec_size > 200000) {
        throw std::invalid_argument("Invalid vector size");
    }
    
      if (vec_size != right_vec.size()) {
        throw std::invalid_argument("Size of both vectors should be equal");
    }

    for (int i = 0; i < vec_size; ++i) {
        if (left_vec[i] < 1 || left_vec[i] > 1000000000 || right_vec[i] < left_vec[i] || right_vec[i] > 1000000000) {
            throw std::invalid_argument("Invalid vector values.");
        }
    }

    const int modulus = 1000000007;
    std::vector<int> len(vec_size + 1, 1), prob(vec_size + 1, 0), l_vec(vec_size + 1, 0), r_vec(vec_size + 1, 0);

    for (int i = 0; i < vec_size; ++i) {
        l_vec[i + 1] = left_vec[i];
        r_vec[i + 1] = right_vec[i];
    }

    int answer = 0;

    for (int i = 1; i <= vec_size; i++) {
        len[i] = QuickPower(r_vec[i] - l_vec[i] + 1, modulus - 2);
    }

    for (int i = 1; i <= vec_size; i++) {
        prob[i] = 1LL * std::max(std::min(r_vec[i], r_vec[i - 1]) - std::max(l_vec[i], l_vec[i - 1]) + 1, 0) * len[i] % modulus * len[i - 1] % modulus;
        answer = (answer + 1 - prob[i]) % modulus;
    }

    for (int i = 3, sum = 0; i <= vec_size; i++) {
        sum = (sum + (1 - prob[i - 2])) % modulus;
        answer = (answer + 2LL * sum * (1 - prob[i]) % modulus) % modulus;
    }

    for (int i = 1; i < vec_size; i++) {
        answer = (answer + 2LL * (1 - prob[i] - prob[i + 1] + 1LL * std::max(std::min({r_vec[i + 1], r_vec[i], r_vec[i - 1]}) - std::max({l_vec[i + 1], l_vec[i], l_vec[i - 1]}) + 1, 0) * len[i + 1] % modulus * len[i] % modulus * len[i - 1] % modulus) % modulus) % modulus;
    }

    return (answer + modulus) % modulus;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>
#include <numeric>
#include <algorithm>

int main() {
    int vec_size;
    std::cin >> vec_size;
    std::vector<int> left_vec(vec_size), right_vec(vec_size);

    for (int i = 0; i < vec_size; i++) {
        std::cin >> left_vec[i];
    }

    for (int i = 0; i < vec_size; i++) {
        std::cin >> right_vec[i];
    }

    //TEST
    int answer = CalculateAnswer(left_vec, right_vec);
    std::cout << answer << std::endl;
    //TEST_END

    return 0;
}

