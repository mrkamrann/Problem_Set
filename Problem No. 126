/*
Link: https://codeforces.com/problemset/problem/331/C3

Yet another Armageddon is coming! This time the culprit is the Mohan tribe calendar.

The beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish 
is as follows:

"May the Great Beaver bless you! May your chakras open and may your third eye never turn blind from beholding the Truth! Take the magic number,  subtract a digit 
from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on 
Three Beavers for the time, equal to the number of subtractions you perform!"

Distinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to 
count the minimum number of operations he needs to reduce the magic number to zero.


Return a single integer â€” the minimum number of subtractions that turns the magic number to a zero.

Create a C++ Function ReduceMagicNumber that will return a long long denoting the minimum number of subtractions required.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.


Input Type:

An integer denoting number

Input Constraints: 

The value of number should be at least 0 and at most 10^18 inclusive.

*/

#include <iostream>
#include <map>
#include <stdexcept>
#include <cassert>
#include <utility>
#include <vector>

std::pair<long long, int> DepthFirstSearch(long long number, int previous_max, std::vector<std::vector<std::vector<std::vector<std::pair<long long, int>>>>>& memo) {
    if (number == 0) {
        return std::make_pair(0ll, 0);
    }
    if (number < 10) {
        return std::make_pair(1ll, std::max(0, previous_max - static_cast<int>(number)));
    }

    int length = 0;
    long long multiplier = 1;
    while (multiplier <= number / 10) {
        multiplier *= 10;
        length++;
    }

    std::pair<long long, int> result = DepthFirstSearch(number % multiplier, std::max(previous_max, static_cast<int>(number / multiplier)), memo);
    if (result.second == 0) {
        result.first++;
        result.second = std::max(previous_max, static_cast<int>(number / multiplier));
    }
    std::pair<long long, int> &current_memo = memo[length][number / multiplier][previous_max][result.second];
    if (!current_memo.first) {
        current_memo = DepthFirstSearch(number / multiplier * multiplier - result.second, previous_max, memo);
    }

    result.first += current_memo.first;
    result.second = current_memo.second;
    return result;
}

long long ReduceMagicNumber(long long number) {

    if (number < 0 || number > 1000000000000000000) {
        throw std::invalid_argument("Number is out of valid range");
    }

    std::vector<std::vector<std::vector<std::vector<std::pair<long long, int>>>>> memo(
        19, 
        std::vector<std::vector<std::vector<std::pair<long long, int>>>>(
            10, 
            std::vector<std::vector<std::pair<long long, int>>>(
                10, 
                std::vector<std::pair<long long, int>>(
                    10, 
                    std::make_pair(0ll, 0)
                )
            )
        )
    );

    return DepthFirstSearch(number, 0, memo).first;
}

#include <iostream>
#include <map>
#include <stdexcept>
#include <cassert>
#include <utility>
#include <vector>

int main() {
  

    return 0;
}
