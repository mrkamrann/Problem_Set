/*
Link: https://codeforces.com/contest/908/problem/E


James is given an integer matrix_size.

Let max_value = 2^matrix_size - 1.

James is also given a set of vector_size integers denoted as the set values. The integers will be provided in base 2 as vector_size binary_strings of length matrix_size.

A set of integers S is called "good" if the following hold:

1. If a, is in S, then a XOR max_value is in S.
2. If a, b are in S, then a AND b is in S.
3. T is a subset of S

All elements of S are less than or equal to max_value. Here, xor and and refer to the bitwise XOR and bitwise AND operators, respectively.

Count the number of good sets S, modulo 10^9 + 7.

Create a C++ Function CountGoodSets that will return a long long denoting the number of good sets.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<string> denoting binary_strings

Input Constraints:

The value of matrix_size should be at least 1 and at most 1000 inclusive.
The value of vector_size should be at least 1 and at most min(2^matrix_size, 50) inclusive.
The length of each binary_string should be exactly matrix_size.
All binary_strings should be distinct.
*/


#include <iostream>
#include <vector>
#include <map>
#include <stdexcept>
#include <cassert>



std::vector<std::vector<long long>> ComputeCombinations(int max_value) {
    std::vector<std::vector<long long>> combinations(max_value + 1, std::vector<long long>(max_value + 1, 0));
    int modulus =  1000000007;
    for (int i = 0; i <= max_value; ++i) {
        for (int j = 0; j <= i; ++j) {
            combinations[i][j] = j ? (combinations[i-1][j-1] + combinations[i-1][j]) % modulus  : 1;
        }
    }
    return combinations;
}

std::vector<long long> ComputeFactorials(int max_value, const std::vector<std::vector<long long>>& combinations) {
    std::vector<long long> factorials(max_value + 1, 0);
    int modulus =  1000000007;
    factorials[0] = factorials[1] = 1;
    for (int i = 2; i <= max_value; ++i) {
        for (int j = 0; j < i; ++j) {
            factorials[i] = (factorials[i] + combinations[i-1][j] * factorials[j]) % modulus ;
        }
    }
    return factorials;
}

long long CountGoodSets(const std::vector<std::string>& binary_strings) {
  
    int matrix_size = binary_strings[0].size(); 
    int vector_size = binary_strings.size();
  
    if (matrix_size < 1 || matrix_size > 1000) {
        throw std::invalid_argument("Matrix size must be between 1 and 1000 inclusive");
    }
    if (vector_size < 1 || vector_size > std::min(2 * matrix_size, 50)) {
        throw std::invalid_argument("Vector size must be between 1 and min(2 * matrix_size, 50) inclusive");
    }
    if (binary_strings.size() != static_cast<size_t>(vector_size)) {
        throw std::invalid_argument("Binary strings vector size does not match the vector size");
    }
    for (const std::string& str : binary_strings) {
        if (str.size() != static_cast<size_t>(matrix_size)) {
            throw std::invalid_argument("Each binary string must have length equal to matrix size");
        }
       for(const char character: str)
       {
         if (character != '0' && character != '1'){
            throw std::invalid_argument("Binary strings must contain only '0' and '1'");
        }
       }
        
    }

   int modulus =  1000000007;
    std::vector<long long> binary_numbers(matrix_size, 0);
    for (int i = 0; i < vector_size; ++i) {
        for (int j = 0; j < matrix_size; ++j) {
            long long bit_value = 0;
            if (binary_strings[i][j] == '1') bit_value = 1;
            binary_numbers[j] |= bit_value << (vector_size - i - 1);
        }
    }

    std::map<long long, long long> frequency_map;
    for (int i = 0; i < matrix_size; ++i) {
        ++frequency_map[binary_numbers[i]];
    }

    std::vector<std::vector<long long>> combinations = ComputeCombinations(matrix_size);
    std::vector<long long> factorials = ComputeFactorials(matrix_size, combinations);
    
    long long answer = 1;
    for (std::map<long long, long long>::iterator it = frequency_map.begin(); it != frequency_map.end(); ++it) {
        answer = (answer * factorials[it->second]) % modulus;
    }
    return answer;
}

#include <iostream>
#include <vector>
#include <map>
#include <stdexcept>
#include <cassert>


int main() {
    int matrix_size, vector_size;
    std::cin >> matrix_size >> vector_size;
    std::vector<std::string> binary_strings(vector_size);
    for (int i = 0; i < vector_size; ++i) {
        std::cin >> binary_strings[i];
    }
   
     std::cout << Solve(binary_strings) << std::endl;
    
    return 0;
}
