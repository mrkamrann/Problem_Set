/*
Link: https://codeforces.com/contest/1634/problem/F


#include <iostream>
#include <vector>
#include <map>
#include <stdexcept>
#include <cassert>



std::vector<std::vector<long long>> ComputeCombinations(int max_value) {
    std::vector<std::vector<long long>> combinations(max_value + 1, std::vector<long long>(max_value + 1, 0));
    int modulus =  1000000007;
    for (int i = 0; i <= max_value; ++i) {
        for (int j = 0; j <= i; ++j) {
            combinations[i][j] = j ? (combinations[i-1][j-1] + combinations[i-1][j]) % modulus  : 1;
        }
    }
    return combinations;
}

std::vector<long long> ComputeFactorials(int max_value, const std::vector<std::vector<long long>>& combinations) {
    std::vector<long long> factorials(max_value + 1, 0);
    int modulus =  1000000007;
    factorials[0] = factorials[1] = 1;
    for (int i = 2; i <= max_value; ++i) {
        for (int j = 0; j < i; ++j) {
            factorials[i] = (factorials[i] + combinations[i-1][j] * factorials[j]) % modulus ;
        }
    }
    return factorials;
}

long long Solve(const std::vector<std::string>& binary_strings) {
  
    int matrix_size = binary_strings[0].size(); 
    int vector_size = binary_strings.size();
  
    if (matrix_size < 1 || matrix_size > 1000) {
        throw std::invalid_argument("Matrix size must be between 1 and 1000 inclusive");
    }
    if (vector_size < 1 || vector_size > std::min(2 * matrix_size, 50)) {
        throw std::invalid_argument("Vector size must be between 1 and min(2 * matrix_size, 50) inclusive");
    }
    if (binary_strings.size() != static_cast<size_t>(vector_size)) {
        throw std::invalid_argument("Binary strings vector size does not match the vector size");
    }
    for (const std::string& str : binary_strings) {
        if (str.size() != static_cast<size_t>(matrix_size)) {
            throw std::invalid_argument("Each binary string must have length equal to matrix size");
        }
       for(const char character: str)
       {
         if (character != '0' && character != '1'){
            throw std::invalid_argument("Binary strings must contain only '0' and '1'");
        }
       }
        
    }

   int modulus =  1000000007;
    std::vector<long long> binary_numbers(matrix_size, 0);
    for (int i = 0; i < vector_size; ++i) {
        for (int j = 0; j < matrix_size; ++j) {
            long long bit_value = 0;
            if (binary_strings[i][j] == '1') bit_value = 1;
            binary_numbers[j] |= bit_value << (vector_size - i - 1);
        }
    }

    std::map<long long, long long> frequency_map;
    for (int i = 0; i < matrix_size; ++i) {
        ++frequency_map[binary_numbers[i]];
    }

    std::vector<std::vector<long long>> combinations = ComputeCombinations(matrix_size);
    std::vector<long long> factorials = ComputeFactorials(matrix_size, combinations);
    
    long long answer = 1;
    for (std::map<long long, long long>::iterator it = frequency_map.begin(); it != frequency_map.end(); ++it) {
        answer = (answer * factorials[it->second]) % modulus;
    }
    return answer;
}

#include <iostream>
#include <vector>
#include <map>
#include <stdexcept>
#include <cassert>


int main() {
    int matrix_size, vector_size;
    std::cin >> matrix_size >> vector_size;
    std::vector<std::string> binary_strings(vector_size);
    for (int i = 0; i < vector_size; ++i) {
        std::cin >> binary_strings[i];
    }
   
     std::cout << Solve(binary_strings) << std::endl;
    
    return 0;
}
