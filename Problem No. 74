/*
Link : https://leetcode.com/problems/strong-password-checker/description/

Julie wants to create a strong secret key that meets the following conditions:

It has at least 6 characters and at most 20 characters.
It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.
It does not contain three repeating characters in a row (i.e., "abbbcd" is weak, but "abbccdd" is strong).
Given a string secret_key, return the minimum number of steps required to make the secret key strong. If the secret key is already strong, return 0.

In one step, Julie can:

Insert one character into the secret key,
Delete one character from the secret key, or
Replace one character of the secret key with another character.

Create a C++ Function StrongSecretKeyChecker that will return an integer denoting the minimum number of steps required.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type

std::string denoting secret_key.

Input Constraints

The length of secret_key should be at least 1 and at most 50 inclusive.
secret_key consists of letters, digits, dot '.' or exclamation mark '!'.

*/


#include <vector>
#include <string>
#include <algorithm>
#include <stdexcept>
#include <cassert>
#include <iostream>

    int GetCharacterValue(char character) {
        if ('a' <= character && character <= 'z') return character - 'a' + 1;
        if ('A' <= character && character <= 'Z') return character - 'A' + 27;
        if ('0' <= character && character <= '9') return character - '0' + 53;
        if (character == '!') return 63;
        return 64;
    }

    int StrongSecretKeyChecker(std::string secret_key) {
      
        if (secret_key.size() < 1 || secret_key.size() > 50) {
            throw std::invalid_argument("The length of secret_key should be at least 1 and at most 50 inclusive.");
        }
        for (char character : secret_key) {
            if (!std::isalnum(character) && character != '.' && character != '!') {
                throw std::invalid_argument("secret_key consists of letters, digits, dot '.' or exclamation mark '!'.");
            }
        }

        int key_length = secret_key.size();
        std::vector<std::vector<std::vector<std::vector<int>>>> dp_table(key_length + 1, 
                std::vector<std::vector<std::vector<int>>>(65, 
                std::vector<std::vector<int>>(16, 
                std::vector<int>(21, 1000))));

        dp_table[0][0][0][0] = 0;

        for (int i = 0; i < key_length; ++i) {
            for (int s = 0; s < 21; ++s) {
                for (int prev_char_value = (s != 0); prev_char_value < 65; ++prev_char_value) {
                    for (int flags = (s == 20 ? 14 : 0); flags < 16; ++flags) {
                        if (dp_table[i][prev_char_value][flags][s] == 1000) continue;

                        int consecutive_flag = flags & 1;
                        int has_uppercase = flags & 2;
                        int has_lowercase = flags & 4;
                        int has_digit = flags & 8;

                        int new_value = dp_table[i][prev_char_value][flags][s] + 1;

                        dp_table[i + 1][prev_char_value][flags][s] = std::min(dp_table[i + 1][prev_char_value][flags][s], new_value);
                        if (s == 20) continue;

                        for (int new_char_value = 1; new_char_value < 65; ++new_char_value) {
                            if (new_char_value == prev_char_value && consecutive_flag) continue;
                            if (new_char_value == 4) { new_char_value = 26; continue; }
                            if (new_char_value == 30) { new_char_value = 52; continue; }
                            if (new_char_value == 56) { new_char_value = 62; continue; }
                            if (1 <= new_char_value && new_char_value <= 26) {
                                dp_table[i][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1] = 
                                    std::min(dp_table[i][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1], new_value);
                            } else if (27 <= new_char_value && new_char_value <= 52) {
                                dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1] = 
                                    std::min(dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1], new_value);
                            } else if (53 <= new_char_value && new_char_value <= 62) {
                                dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1] = 
                                    std::min(dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1], new_value);
                            } else {
                                dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1] = 
                                    std::min(dp_table[i][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1], new_value);
                            }
                        }

                        for (int new_char_value = 1; new_char_value < 65; ++new_char_value) {
                            if (new_char_value == prev_char_value && consecutive_flag) continue;
                            if (new_char_value == 4) { new_char_value = 26; continue; }
                            if (new_char_value == 30) { new_char_value = 52; continue; }
                            if (new_char_value == 56) { new_char_value = 62; continue; }
                            int new_value_replaced = new_value - (new_char_value == GetCharacterValue(secret_key[i]));
                            if (1 <= new_char_value && new_char_value <= 26) {
                                dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1] = 
                                    std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1], new_value_replaced);
                            } else if (27 <= new_char_value && new_char_value <= 52) {
                                dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1] = 
                                    std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1], new_value_replaced);
                            } else if (53 <= new_char_value && new_char_value <= 62) {
                                dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1] = 
                                    std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1], new_value_replaced);
                            } else {
                                dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1] = 
                                    std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1], new_value_replaced);
                            }
                        }

                        int new_char_value = GetCharacterValue(secret_key[i]);
                        if (new_char_value == prev_char_value && consecutive_flag) continue;
                        int new_value_kept = new_value - 1;
                        if (1 <= new_char_value && new_char_value <= 26) {
                            dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1] = 
                                std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + 2 + has_lowercase + has_digit][s + 1], new_value_kept);
                        } else if (27 <= new_char_value && new_char_value <= 52) {
                            dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1] = 
                                std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + 4 + has_digit][s + 1], new_value_kept);
                        } else if (53 <= new_char_value && new_char_value <= 62) {
                            dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1] = 
                                std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + 8][s + 1], new_value_kept);
                        } else {
                            dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1] = 
                                std::min(dp_table[i + 1][new_char_value][(new_char_value == prev_char_value) + has_uppercase + has_lowercase + has_digit][s + 1], new_value_kept);
                        }
                    }
                }
            }
        }

         int min_steps = 1000;
        for (int i = 0; i < 65; ++i) {
            for (int length = 6; length <= 20; ++length) {
                min_steps = std::min(min_steps, dp_table[key_length][i][15][length]);
                min_steps = std::min(min_steps, dp_table[key_length][i][14][length]);
            }
        }
        return min_steps;
    }

int main(){
  return 0;
}
