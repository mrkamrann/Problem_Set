/*
Link: https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/description/

Julie is given an undirected graph (the "original graph") with len nodes labeled from 0 to len - 1. She decides to subdivide each edge in the graph into a chain 
of nodes, with the number of new nodes varying between each edge.

The graph is given as a 2D vector of edges where edges[i] = [u_i, v_i, cnt_i] indicates that there is an edge between nodes u_i and v_i in the original graph, 
and cnt_i is the total number of new nodes that you will subdivide the edge into. 

Note that cnt_i == 0 means you will not subdivide the edge.

To subdivide the edge [u_i, v_i], replace it with (cnt_i + 1) new edges and cnt_i new nodes. The new nodes are x_1, x_2, ..., x_cnt_i, and the new edges 
are [u_i, x_1], [x_1, x_2], [x_2, x_3], ..., [x_cnt_i-1, x_cnt_i], [x_cnt_i, v_i].

In this new graph, Julie wants to know how many nodes are reachable from node 0, where a node is reachable if the distance is max_moves or less.

Given the original graph and max_moves, return the number of nodes that are reachable from node 0 in the new graph.

Create a C++ Function ReachableNodes that will return an integer denoting the number of nodes that are reachable from node 0 in the new graph.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.


Input Type:

A vector<vector<int>> denoting edges
An integer denoting max_moves
An integer denoting len

Input Constraints:

The length of edges should be at least 0 and at most min(len * (len - 1) / 2, 10^4) inclusive.
Each edge should be a vector of size 3.
Each value of u_i should be in the range [0, len - 1] inclusive.
Each value of v_i should be in the range [0, len - 1] inclusive.
There are no multiple edges in the graph
Each value of cnt_i should be in the range [0, 10^4] inclusive.
Each value of max_moves should be in the range [0, 10^9] inclusive.
The value of len should be at least 1 and at most 3000 inclusive.

*/

#include <vector>
#include <queue>
#include <stdexcept>
#include <cassert>

    void Dijkstra(std::vector<int>& distances, std::vector<std::vector<std::pair<int, int>>>& graph, int max_moves) {
        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>> priority_queue;
        priority_queue.push({max_moves, 0});
        distances[0] = max_moves;

        while (!priority_queue.empty()) {
            int remaining_moves = priority_queue.top().first;
            int node = priority_queue.top().second;
            priority_queue.pop();

            if (remaining_moves == distances[node]) {
                for (std::size_t i = 0; i < graph[node].size(); ++i) {
                    int adjacent_node = graph[node][i].first;
                    int edge_weight = graph[node][i].second;

                    if (remaining_moves - (edge_weight + 1) >= 0 && distances[adjacent_node] < (remaining_moves - (edge_weight + 1))) {
                        distances[adjacent_node] = remaining_moves - (edge_weight + 1);
                        priority_queue.push({remaining_moves - (edge_weight + 1), adjacent_node});
                    }
                }
            }
        }
    }

    int ReachableNodes(std::vector<std::vector<int>>& edges, int max_moves, int num_nodes) {
        if (num_nodes < 1 || num_nodes > 3000 || max_moves < 0 || max_moves > 1000000000 || edges.size() > std::min(num_nodes * (num_nodes - 1) / 2, 10000)) {
            throw std::invalid_argument("Input constraints are violated.");
        }

        for (const vector<int>& edge : edges) {
            if (edge.size() != 3 || edge[0] < 0 || edge[0] >= num_nodes || edge[1] < 0 || edge[1] >= num_nodes || edge[2] < 0 || edge[2] > 10000) {
                throw std::invalid_argument("Each edge must be a vector of size 3 with valid u_i, v_i, and cnt_i.");
            }
        }

        std::vector<int> distances(num_nodes, -1);
        std::vector<std::vector<std::pair<int, int>>> graph(num_nodes);

        for (std::size_t i = 0; i < edges.size(); ++i) {
            graph[edges[i][0]].emplace_back(edges[i][1], edges[i][2]);
            graph[edges[i][1]].emplace_back(edges[i][0], edges[i][2]);
        }

        Dijkstra(distances, graph, max_moves);

        int result = 0;

        for (std::size_t i = 0; i < edges.size(); ++i) {
            int sum_1 = (distances[edges[i][0]] != -1) ? distances[edges[i][0]] : 0;
            int sum_2 = (distances[edges[i][1]] != -1) ? distances[edges[i][1]] : 0;
            result += std::min(edges[i][2], sum_1 + sum_2);
        }

        for (int distance : distances) {
            if (distance != -1) {
                ++result;
            }
        }

        return result;
    }


int main() {
  
  
    //TEST

    //TEST_END
    return 0;
}
