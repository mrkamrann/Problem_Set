/*
Link: https://codeforces.com/contest/388/problem/D

Snoop Dog studies number theory.

He thinks a non-empty set S containing non-negative integers is perfect if and only if for any a, b ∈ S a,b ∈ S (a can be equal to b), 𝑎 ⊕ 𝑏 ∈ 𝑆. The operation ⊕ 
denotes the bitwise exclusive OR (XOR) operation.

Snoop Dog is interested in finding out the number of perfect sets consisting of integers not greater than limit. The answer can be very large, so he needs to
returb it modulo 1000000007 (10^9 + 7).

To elaborate, a set S is perfect if for every pair of elements a and b in S, the result of  a⊕b is also an element in S. For example, if  S = {1,2,3}, then it should satisfy:

1 ⊕ 1 ∈ S

1 ⊕ 2 ∈ S

1 ⊕ 3 ∈ S

2 ⊕ 2 ∈ S

2 ⊕ 3 ∈ S

3 ⊕ 3 ∈ S

Given the integer limit, determine the number of such perfect sets where every element in the set is less than or equal to limit.

Return a single number — the number of required sets modulo 1000000007 (10^9 + 7).

Create a C++ function CountPerfectSets that will return an integer denoting the number of perfect sets consisting of integers not greater than limit.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An integer denoting limit

Input Constraints:

The value of limit should be in the range [0, 10^9] inclusive.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cstdio>
#include <cassert>



int DepthFirstSearch(int bit_position, int leading_bits, bool is_max, const std::vector<int>& bits, std::vector<std::vector<std::vector<int>>>& dp_table) {
    if (bit_position == -1) {
        return 1;
    }
    int modulus = 1e9 + 7;
    int& result = dp_table[bit_position][leading_bits][is_max];
    if (result) {
        return result;
    }
    if (!is_max || bits[bit_position]) {
        result = DepthFirstSearch(bit_position - 1, leading_bits + 1, is_max, bits, dp_table);
    }
    for (int i = 0; i <= (leading_bits && (is_max ? bits[bit_position] : 1)); ++i) {
        result = (result + static_cast<long long>(DepthFirstSearch(bit_position - 1, leading_bits, is_max && i == bits[bit_position], bits, dp_table)) * std::max((1 << leading_bits >> 1), 1)) % modulus;
    }
    return result;
}

int CountPerfectSets(int limit) {
  
    if (limit < 0 || limit > 1000000000) {
        throw std::invalid_argument("Limit should lie between 1 and 1000000000");
    }
    
    std::vector<int> bits;
    while (limit) {
        bits.push_back(limit & 1);
        limit >>= 1;
    }
    
    std::vector<std::vector<std::vector<int>>> dp_table(bits.size(), std::vector<std::vector<int>>(30, std::vector<int>(2, 0)));
    
    return DepthFirstSearch(bits.size() - 1, 0, true, bits, dp_table);
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cstdio>
#include <cassert>

int main() {
    
    return 0;
}
