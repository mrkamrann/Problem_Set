/*
Link : https://leetcode.com/problems/zuma-game/description/

Julie is playing a variation of the game Zuma. In this game, there is a single row of colored balls on a board. Each ball can be colored red ('R'), yellow ('Y'), blue ('B'), green ('G'), or white ('W'). Julie also has several colored balls in her hand.

The objective of the game is to clear all the balls from the board. Julie can achieve this by performing the following steps on each turn:

Insert a Ball:

Julie can pick any ball from her hand and insert it in between two balls in the row or on either end of the row.

Remove Consecutive Balls:

If the insertion of the ball creates a group of three or more consecutive balls of the same color, that group is removed from the board.
This removal process continues recursively if new groups of three or more consecutive balls are formed as a result.

Winning Condition:

Julie wins the game if she clears all the balls from the board.
The process is repeated until Julie either clears the board or runs out of balls in her hand.

Given a string board representing the row of balls on the board, and a string hand representing the balls in Julie's hand, the task is to determine 
the minimum number of balls Julie needs to insert to clear all the balls from the board. If it is not possible to clear the board using the balls in her hand, 
return -1.

Create a C++ Function FindMinStep that will return the minimum number of balls needed to clear the board or -1 if it's not possible.

Use appropriate Error Handling using the stdexcept library for invalid test cases.

Input Type:

A string board representing the row of balls on the board.
A string hand representing the balls in Julie's hand.

Input Constraints:

The length of the board should be in the range [1, 16] inclusive.
The length of the hand should be in the range [1, 5] inclusive.
Both board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.
The initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.


*/

#include <unordered_map>
#include <string>
#include <vector>
#include <stdexcept>
#include <cassert>
#include <iostream>
#include <functional>

class Solution {
public:
    int FindMinStep(std::string board, std::string hand) {
        if (board.length() < 1 || board.length() > 16 || hand.length() < 1 || hand.length() > 5) {
            throw std::invalid_argument("Board length must be in the range [1, 16] and hand length in the range [1, 5]");
        }


        for (char character : hand) {
            if (character != 'R' && character != 'Y' && character != 'B' && character != 'G' && character != 'W') {
                throw std::invalid_argument("Board and hand must consist of characters 'R', 'Y', 'B', 'G', and 'W'");
            }
        }

        for (int i = 0; i < board.size(); ++i) {
            int count = 1;
            while (i + 1 < board.size() && board[i + 1] == board[i]) {
                ++count;
                ++i;
            }
            if (count >= 3) {
                throw std::invalid_argument("Initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.");
            }
        }

        std::unordered_map<std::string, int> dp_map;
        char colors[] = {'R', 'G', 'B', 'Y', 'W'};
        std::function<int(std::string)> FinalSteps;

        FinalSteps = [&](std::string state) -> int {
            if (dp_map.count(state)) return dp_map[state];
            if (state[0] == '#') return 0;

            int split_pos = state.find('#');
            std::string current_board = state.substr(0, split_pos);
            std::string current_hand = state.substr(split_pos + 1);
            int board_length = current_board.size();
            int minimum_steps = 2000000000;

            for (int i = 0; i < board_length; i++) {
                for (int j = 0; j < 5; j++) {
                    if (current_hand[j] == '0') continue;
                    if (i < board_length - 1 && current_board[i + 1] != current_board[i] && current_hand[j] == '1') continue;

                    std::string new_board = current_board;
                    new_board.insert(new_board.begin() + i, colors[j]);
                    std::string new_hand = current_hand;
                    new_hand[j] -= 1;

                    bool continue_loop = true;
                    while (continue_loop) {
                        int new_board_length = new_board.size();
                        continue_loop = false;
                        for (int k = 0; k < new_board_length; k++) {
                            int ptr = k;
                            for (; ptr < new_board_length && new_board[ptr] == new_board[k]; ptr++) {}
                            if (ptr - k >= 3) {
                                new_board.erase(new_board.begin() + k, new_board.begin() + ptr);
                                continue_loop = true;
                                break;
                            }
                            k = ptr - 1;
                        }
                    }
                    minimum_steps = std::min(minimum_steps, std::min(FinalSteps(new_board + '#' + new_hand) + 1, 2000000000));
                }
            }
            return dp_map[state] = minimum_steps;
        };

        std::unordered_map<char, int> hand_count;
        for (char character : hand) hand_count[character]++;
        std::string hand_state(5, '0');
        for (int i = 0; i < 5; i++) hand_state[i] = char('0' + hand_count[colors[i]]);

        int result = FinalSteps(board + '#' + hand_state);
        return result == 2000000000 ? -1 : result;
    }
};

int main(){
  Solution solution;
  //TEST
  
  
  //TEST_END
}
