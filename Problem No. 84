/*
Link: https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum/description/

Julie is given a 0-indexed vector nums of non-negative integers, and two integers low and high.

Return the count of sub-multisets within nums where the sum of elements in each subset falls within the inclusive range of [low, high].

Since the answer may be large, return it modulo 10^9 + 7.

A sub-multiset is an unordered collection of elements of the vector in which a given value x can occur 0, 1, ..., occ[x] times,
where occ[x] is the number of occurrences of x in the vector.

Note that:

Two sub-multisets are the same if sorting both sub-multisets results in identical multisets.
The sum of an empty multiset is 0.

Create a C++ class Solution that will contain a function CountSubMultisets that will return an integer denoting the the count of sub-multisets.
Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<int> denoting nums
An integer denoting low
An integer denoting high

Input Constraints:

The length of nums should be at least 1 and at most 20,000 inclusive.
Each value of nums[i] should be in the range [0, 20,000] inclusive.
The sum of nums should not exceed 20,000.
The values for low and high should be in the range [0, 20,000] inclusive.

*/

#include <vector>
#include <map>
#include <algorithm>
#include <stdexcept>
#include <cstring>
#include <iostream>
#include <cassert>

class Solution {
private:
    const int mod_value = 1e9 + 7;
    std::vector<std::pair<int, int>> value_pairs;
    int dp_table_1[201][20010];
    int dp_table_2[201][20010];
    int num_elements;

    int RecursiveCount(int level, int sum_left) {
        if (sum_left < 0) {
            return 0;
        }
        if (level == num_elements) {
            if (sum_left) {
                return 0;
            }
            return 1;
        }
        int &answer = dp_table_1[level][sum_left];
        if (answer != -1) {
            return answer;
        }
        if (value_pairs[level].first) {
            answer = (RecursiveCount(level + 1, sum_left) + CalculateSubsets(level + 1, sum_left)) % mod_value;
            answer -= CalculateSubsets(level + 1, sum_left - (value_pairs[level].first * value_pairs[level].second));
            answer %= mod_value;
            if (answer < 0) {
                answer += mod_value;
            }
        } else {
            answer = (1LL * RecursiveCount(level + 1, sum_left) * (value_pairs[level].second + 1)) % mod_value;
        }
        return answer;
    }

    int CalculateSubsets(int level, int sum_left) {
        if (sum_left < 0) {
            return 0;
        }
        if (dp_table_2[level][sum_left] != -1) {
            return dp_table_2[level][sum_left];
        }
        int answer = (CalculateSubsets(level, sum_left - value_pairs[level - 1].first) + RecursiveCount(level, sum_left - value_pairs[level - 1].first)) % mod_value;
        return dp_table_2[level][sum_left] = answer;
    }

public:
    int countSubMultisets(std::vector<int>& nums, int low, int high) {
        if (nums.size() < 1 || nums.size() > 20000) {
            throw std::invalid_argument("The length of nums should be at least 1 and at most 20,000 inclusive.");
        }
        int total_sum = 0;
        std::map<int, int> count_map;
        for (std::vector<int>::iterator it = nums.begin(); it != nums.end(); ++it) {
            if (*it < 0 || *it > 20000) {
                throw std::invalid_argument("Each value of nums[i] should be in the range [0, 20,000] inclusive.");
            }
            total_sum += *it;
            count_map[*it]++;
        }
        if (total_sum > 20000) {
            throw std::invalid_argument("The sum of nums should not exceed 20,000.");
        }
        num_elements = count_map.size();
        value_pairs.clear();
        for (std::map<int, int>::iterator it = count_map.begin(); it != count_map.end(); ++it) {
            value_pairs.push_back({it->first, it->second});
        }
        high = std::min(high, total_sum);
        if (low < 0 || low > 20000 || high < 0 || high > 20000) {
            throw std::invalid_argument("The values for low and high should be in the range [0, 20,000] inclusive.");
        }
        for (int i = 0; i <= num_elements; i++) {
            for (int j = 0; j <= high; j++) {
                dp_table_1[i][j] = dp_table_2[i][j] = -1;
            }
        }
        int result = 0;
        for (int sum_left = low; sum_left <= high; sum_left++) {
            result = (result * 1LL + RecursiveCount(0, sum_left)) % mod_value;
        }
        return result;
    }
};

int main(){

Solution solution;

return 0;

}
