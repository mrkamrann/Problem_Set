/*
Link: https://codeforces.com/contest/1312/problem/F

Avy is responsible for defending the Red Kingdom, which is under attack by the White King and the Black King. The Kingdom is guarded by length castles, with each 
castle i defended by values[i] soldiers. To conquer the Red Kingdom, the Kings must eliminate all defenders.

Each day, the White King launches an attack on one of the castles. Then, at night, the Black King attacks a castle (possibly the same one). The attacks alternate
between the White King and the Black King, starting with the White King.

Each attack must target a castle with at least one soldier. There are three types of attacks:

A mixed attack decreases the number of defenders in the targeted castle by x_value (or sets it to 0 if there are already fewer than x_value defenders).
An infantry attack decreases the number of defenders in the targeted castle by y_value (or sets it to 0 if there are already fewer than y_value defenders).
A cavalry attack decreases the number of defenders in the targeted castle by z_value (or sets it to 0 if there are already fewer than z_value defenders).
The mixed attack can target any valid castle (with at least one soldier). However, the infantry and cavalry attacks cannot be launched on a castle if the previous attack on it was of the same type, regardless of when or by whom it was launched. A castle that hasn't been attacked can be targeted by any type of attack.

The King who launches the last attack will be glorified as the conqueror of the Red Kingdom. The White King is planning his first attack, and you are responsible 
for determining the number of possible first attack options that allow the White King to launch the last attack. Each option for the first attack is represented 
by the targeted castle and the type of attack. Two options are different if the targeted castles or the types of attack are different.


Create a C++ function CalculateFirstAttackOptions that will return an integer denoting the number of possible options for the first attack of the
White King (or 0 if the Black King can launch the last attack no matter how the White King acts). 

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

An Integer denoting length
An Integer denoting x_value
An Integer denoting y_value
An Integer denoting z_value
A vector of integers values representing the number of soldiers in each castle.

Input Constraints

The length of values should be at least 1 and at most 300,000 inclusive.
Each value of values[i] should be in the range [1, 10^18] inclusive.
The values for length, x_value, y_value, and z_value should be in the range [1, 5] inclusive.
The number of test cases should be at least 1 and at most 1000 inclusive.
The sum of length values across all test cases should not exceed 300,000.


*/

#include <iostream>
#include <vector>
#include <unordered_map>
#include <stdexcept>
#include <cassert>


long long SuffixGrundy(long long index, long long offset, const std::vector<std::vector<long long>>& grundy_values, long long first_cycle, long long cycle_length) {
    if (index > first_cycle) {
        index = first_cycle + (index - first_cycle) % cycle_length;
    }
    return grundy_values[index][offset];
}

int CalculateFirstAttackOptions(long long length, long long x_value, long long y_value, long long z_value, std::vector<long long>& values) {
  
    if (length < 1 || length > 300000){
      throw std::invalid_argument("Invalid length");
    }
    if (x_value < 1 || x_value > 5 || y_value < 1 || y_value > 5 || z_value < 1 || z_value > 5){
       throw std::invalid_argument("Invalid x, y, or z value");
    }
    for (long long value : values) {
        if (value < 1 || value > 1000000000000000000){
          throw std::invalid_argument("Invalid value in values");
        }
    }

    std::vector<std::vector<long long>> grundy_values(1010, std::vector<long long>(4));
    std::vector<long long> visited(5);
    long long first_cycle, cycle_length;
    std::unordered_map<long long, long long> state_map;

    for (int i = 5;; i++) {
        for (int j = 0; j < 3; j++) grundy_values[i][j] = 0;
        std::fill(visited.begin(), visited.end(), 0);
        visited[grundy_values[i - x_value][0]] = visited[grundy_values[i - y_value][1]] = visited[grundy_values[i - z_value][2]] = 1;
        while (visited[grundy_values[i][0]]) grundy_values[i][0]++;
        std::fill(visited.begin(), visited.end(), 0);
        visited[grundy_values[i - x_value][0]] = visited[grundy_values[i - z_value][2]] = 1;
        while (visited[grundy_values[i][1]]) grundy_values[i][1]++;
        std::fill(visited.begin(), visited.end(), 0);
        visited[grundy_values[i - x_value][0]] = visited[grundy_values[i - y_value][1]] = 1;
        while (visited[grundy_values[i][2]]) grundy_values[i][2]++;
        grundy_values[i][3] = grundy_values[i][0] * 16 + grundy_values[i][1] * 4 + grundy_values[i][2];
        long long state = 0;
        for (int j = i - 4; j <= i; j++) state = state * 64 + grundy_values[j][3];
        if (state_map[state]) {
            first_cycle = state_map[state] - 4;
            cycle_length = i - state_map[state];
            break;
        }
        state_map[state] = i;
    }

    long long answer = 0, result = 0;
    for (int i = 0; i < length; i++) {
        values[i] += 4;
        answer ^= SuffixGrundy(values[i], 0, grundy_values, first_cycle, cycle_length);
    }

    for (int i = 0; i < length; i++) {
        if (!(answer ^ SuffixGrundy(values[i], 0, grundy_values, first_cycle, cycle_length) ^ SuffixGrundy(values[i] - x_value, 0, grundy_values, first_cycle, cycle_length))) result++;
        if (!(answer ^ SuffixGrundy(values[i], 0, grundy_values, first_cycle, cycle_length) ^ SuffixGrundy(values[i] - y_value, 1, grundy_values, first_cycle, cycle_length))) result++;
        if (!(answer ^ SuffixGrundy(values[i], 0, grundy_values, first_cycle, cycle_length) ^ SuffixGrundy(values[i] - z_value, 2, grundy_values, first_cycle, cycle_length))) result++;
    }

    return result;
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);

    long long test_cases;
    std::cin >> test_cases;
    while (test_cases--) {
        long long length, x_value, y_value, z_value;
        std::cin >> length >> x_value >> y_value >> z_value;
        std::vector<long long> values(length);
        for (int i = 0; i < length; i++) {
            std::cin >> values[i];
        }
        std::cout << CalculateResult(length, x_value, y_value, z_value, values) << "\n";
    }

    return 0;
}
