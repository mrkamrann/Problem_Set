/*
Link: https://codeforces.com/contest/1523/problem/E

Jim is conducting an experiment with a deck of cards. The deck consists of column_count cards, and exactly one card is a joker. Jim performs the following 
experiment row_count times: he shuffles the deck, takes the top card of the deck, looks at it, and then returns it into the deck.

Let x_count be the number of times Jim takes the joker out of the deck during this experiment. Assuming that every time Jim shuffles the deck, all column_count!
possible permutations of cards are equally probable, what is the expected value of x_count^k_value? Print the answer modulo 998244353.

Create a C++ function CalculateExpectedValue that will return a long long denoting the expected value of x_count^k_value modulo 998244353.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

An integer row_count denoting the number of times Jim performs the experiment
An integer column_count denoting the number of cards in the deck
An integer k_value denoting the exponent

Input Constraints

The value of row_count should be in the range [1, 998244352] inclusive.
The value of column_count should be in the range [1, 998244352] inclusive.
The value of k_value should be in the range [1, 5000] inclusive.


*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

long long CalculatePower(long long base, long long exponent) {
    long long result = 1;
    const long long modulus = 1000000007;
    while (exponent) {
        if (exponent & 1) {
            result = result * base % modulus;
        }
        base = base * base % modulus;
        exponent >>= 1;
    }
    return result;
}

long long ComputeCombination(long long m_val, long long n_val, const std::vector<long long>& factorials) {
    if (n_val < 0 || m_val < 0 || m_val < n_val) {
        return 0;
    }
    const long long modulus = 1000000007;
    return factorials[m_val] * CalculatePower(factorials[n_val], modulus - 2) % modulus * CalculatePower(factorials[m_val - n_val], modulus - 2) % modulus;
}

long long CalculateExpectedValue(long long row_count, long long k_value) {
    if (row_count < 2 || row_count > 100000) {
        throw std::invalid_argument("row_count is out of bounds");
    }
    if (k_value < 2 || k_value > row_count) {
        throw std::invalid_argument("k_value is out of bounds");
    }
    const long long modulus = 1000000007;
    const long long max_size = 100100;
  
    std::vector<long long> factorials(max_size, 1);
    for (long long i = 1; i < max_size; ++i) {
        factorials[i] = factorials[i - 1] * i % modulus;
    }

    long long answer = 1;
    for (long long i = 1; i < row_count; ++i) {
        answer = (answer + ComputeCombination(row_count - (i - 1) * (k_value - 1), i, factorials) * CalculatePower(ComputeCombination(row_count, i, factorials), modulus - 2) % modulus) % modulus;
    }
    return answer;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    long long test_cases;
    std::cin >> test_cases;

    if (test_cases < 1) {
        throw std::invalid_argument("test_cases should be at least 1");
    }

    for (long long t = 0; t < test_cases; ++t) {
        long long row_count, k_value;
        std::cin >> row_count >> k_value;

        try {
            long long result = ComputeAnswer(row_count, k_value);
            std::cout << result << std::endl;
        } catch (const std::invalid_argument& e) {
            std::cerr << "Invalid input: " << e.what() << std::endl;
            return 1;
        }
    }

    return 0;
}

