/*
Link : https://leetcode.com/problems/split-array-with-same-average/description/ 

Julie has an integer vector named nums.

Julie wants to split nums into two non-empty vectors vector_a and vector_b such that the average of vector_a is equal to the average of vector_b.

Return true if it is possible for Julie to split the vector in this way and false otherwise.

Note that for a vector vec, average(vec) is calculated as the sum of all the elements of vec divided by the number of elements in vec.

Create a C++ class Solution that will contain a function splitVectorSameAverage that will return an integer denoting the minimum number of trips required.

Use appropriate error handling using the stdexcept library for the invalid test cases.


Input Type:

A vector<int> denoting nums.

Constraints:

The length of nums must be at least 1 and at most 30 inclusive.
Each value in nums must be between 0 and 10,000 inclusive.

*/

#include <vector>
#include <algorithm>
#include <stdexcept>
#include <cassert>

class Solution {
    int total_sum, num_elements;
    int power_of_two[24];
    
public:
    std::vector<std::vector<int>> MakeSubset(std::vector<int>& nums, int left_index, int right_index) {
        int max_combinations = 1 << (right_index - left_index);
        std::vector<std::vector<int>> subsets;

        for (int i = 0; i < max_combinations; i++) {
            int subset_sum = 0;
            int num_subset_elements = 0;

            for (int j = left_index; j < right_index; j++) {
                if (i & power_of_two[j - left_index]) {
                    subset_sum += nums[j];
                    num_subset_elements++;
                }
            }

            int value = subset_sum * num_elements - (num_subset_elements * total_sum);
            subsets.push_back({value, num_subset_elements});
        }

        return subsets;
    }

    int SearchSubset(const std::vector<std::vector<int>>& subsets, int target_value) {
        int index = subsets.size();
        int left = 0, right = subsets.size() - 1;

        while (left <= right) {
            int middle = left + (right - left) / 2;
            if (subsets[middle][0] >= target_value) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }

        while (left >= 0 && left < subsets.size() && subsets[left][0] == target_value) {
            index = left;
            left--;
        }

        return index;
    }

    bool SplitVectorSameAverage(std::vector<int>& nums) {
      
        if (nums.size() < 1 || nums.size() > 30) {
            throw std::invalid_argument("nums length must be between 1 and 30 inclusive.");
        }

        for (int num : nums) {
            if (num < 0 || num > 10'000) {
                throw std::invalid_argument("Each value in nums must be between 0 and 10,000 inclusive.");
            }
        }

        num_elements = nums.size();
        if (num_elements < 2) {
            return false;
        }

        power_of_two[0] = 1;
        for (int i = 1; i < 24; i++) {
            power_of_two[i] = power_of_two[i - 1] << 1;
        }

        total_sum = 0;
        for (int num : nums) {
            total_sum += num;
        }

        int mid_index = num_elements / 2;
        std::vector<std::vector<int>> left_subsets = MakeSubset(nums, 0, mid_index);
        std::vector<std::vector<int>> right_subsets = MakeSubset(nums, mid_index, num_elements);

        std::sort(right_subsets.begin(), right_subsets.end());

        for (const std::vector<int>& left_subset : left_subsets) {
            int index = SearchSubset(right_subsets, -left_subset[0]);

            while (index < right_subsets.size() && right_subsets[index][0] == -left_subset[0]) {
                if (left_subset[1] + right_subsets[index][1] < num_elements && left_subset[1] + right_subsets[index][1] > 0) {
                    return true;
                }
                index++;
            }
        }

        return false;
    }
};

int main(){
  return 0;
}


