/*
Link : https://codeforces.com/problemset/problem/1221/E

Julie and Rob are playing a game. Initially, they have a string str composed solely of characters . and X. The game proceeds as follows:

Julie and Rob take turns alternately, with Julie always going first.
On each turn, the player must select a contiguous substring of characters . (dots) and replace each dot with X.
Julie must select a substring of length val_a, while Rob must select a substring of length val_b. It is guaranteed that val_a is strictly greater than val_b.
For example, if str = "....X..", val_a = 3, and val_b = 2, then after Julie's move, the string could turn into "XXX.X..". If it is Rob's turn and the string is "....X..", then after Rob's move, 
the string could become "XX..X..", ".XXX..", or "..XXX..".

The game ends when a player cannot make a move, and that player loses. You need to determine who will win if both Julie and Rob play optimally.

Return true if Julie can win and false otherwise.

Create a C++ function DetermineWinner that will return a boolean indicating whether Julie can win.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An Integer denoting val_a
An Integer denoting val_b
A string denoting str

Input Constraints:

The value of val_a and val_b should be such that 1 ≤ val_b < val_a ≤ 300,000 inclusive.
The length of string str should be at least 1 and at most 300,000 inclusive.
str should only contain '.' and 'X'


*/

#include <iostream>
#include <string>
#include <stdexcept>
#include <cassert>


    bool DetermineWinner(int val_a, int val_b, std::string &str)
    {
        if (val_b < 1 || val_b >= val_a || val_a > 300000 || val_a < 1 || val_b > 300000) {
            throw std::invalid_argument("Invalid input values for val_a or val_b.");
        }
        if (str.length() < 1 || str.length() > 300000) {
            throw std::invalid_argument("Invalid input length for str.");
        }
        for (char character : str) {
            if (character  != '.' && character  != 'X') {
                throw std::invalid_argument("Invalid character in str. Only '.' and 'X' are allowed.");
            }
        }

        int count_2 = 0;
        int count_3 = 0;
        int count_4 = 0;
        int length = 0;
        int dot_count = 0;

        for (std::size_t i = 0; i <= str.length() && count_2 == 0 && count_4 < 2; i++) {
            if (i < str.length() && str[i] == '.') {
                dot_count++;
            } else {
                if (dot_count >= val_b && dot_count < val_a) {
                    count_2++;
                } else if (dot_count >= val_a && dot_count < 2 * val_b) {
                    count_3++;
                } else if (dot_count >= 2 * val_b) {
                    count_4++;
                    length = dot_count;
                }
                dot_count = 0;
            }
        }

        bool condition_1 = length >= 2 * val_b && length <= (val_a + 2 * val_b - 2);
        bool condition_2 = length >= 2 * val_a && length < (val_a + 3 * val_b - 1);
        bool condition_3 = length >= 3 * val_a && length <= (val_a + 4 * val_b - 2);

        if (count_2 || count_4 > 1) return false;
        else if (((count_3 % 2 == 0) && (condition_1 || condition_3)) || ((count_3 % 2) && (!count_4 || condition_2))) return true;

        return false;
    }


int main() {
   
    return 0;
}
