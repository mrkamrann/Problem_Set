/*
Link: https://codeforces.com/contest/1067/problem/E

Let's define the rank of an undirected graph as the rank of its adjacency matrix in R^(num_nodes × num_nodes).

Given a tree, each edge of this tree will be deleted with probability 1/2, and all these deletions are independent. Let E be the expected rank of the resulting 
forest. Find E · 2^(num_nodes-1) modulo 998244353 (it is easy to show that E · 2^(num_nodes-1) is an integer).

You are given a 2D vector of size num_nodes - 1 where num_nodes — the number of vertices,  contain two integers u and v — indices of vertices connected by edge.

Return one long long — the answer to the problem.

Create a C++ function CalculateExpectedRank that will return a long long denoting the answer to the problem.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

A vector<vector<int>> edges

Input Constraints:

The value of num_nodes should be at least 1 and at most 5 × 10^5 inclusive.
Each edge should connect distinct nodes within the range [1, num_nodes].

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

void DepthFirstSearch(int node, int parent, const std::vector<std::vector<int>> &adjacency_list, std::vector<int> &function_values, long long &result) {
  
    int multiplier = 1;
    int modulo = 998244353;
  
    int inverse_modulo = (modulo + 1) >> 1;
  
    for (size_t i = 0; i < adjacency_list[node].size(); ++i) {
        int neighbor = adjacency_list[node][i];
        if (neighbor != parent) {
            DepthFirstSearch(neighbor, node, adjacency_list, function_values, result);
            multiplier = static_cast<long long>(multiplier) * inverse_modulo % modulo * (modulo + 2 - function_values[neighbor]) % modulo;
        }
    }
    result += modulo + 1 - multiplier;
    function_values[node] = multiplier;
}

long long CalculateExpectedRank(const std::vector<std::vector<int>> &edges) {

    int num_nodes = edges.size();

    if (num_nodes < 1 || num_nodes > 500000) {
        throw std::invalid_argument("Invalid number of nodes");
    }
    for (size_t i = 0; i < edges.size(); ++i) {

        int u_val = edges[i][0];
        int v_val = edges[i][1];
        if (u_val < 1 || u_val > num_nodes || v_val < 1 || v_val > num_nodes || u_val == v_val) {
            throw std::invalid_argument("Invalid edge");
        }
    }
  
    int modulo = 998244353;
    int inverse_modulo = (modulo + 1) >> 1;
  
    std::vector<std::vector<int>> adjacency_list(num_nodes + 1);
    std::vector<int> function_values(num_nodes + 1, 0);
    long long result = 0;

   for (const std::vector<int> &edge : edges) {
     
        adjacency_list[edge[0]].push_back(edge[1]);
        adjacency_list[edge[1]].push_back(edge[0]);
    }

    DepthFirstSearch(1, 0, adjacency_list, function_values, result);

    for (int i = 0; i < num_nodes; ++i) {
        result = result * 2 % modulo;
    }

    return result;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    int num_nodes;
    std::cin >> num_nodes;

    std::vector<std::vector<int>> edges(num_nodes - 1);
    for (int i = 0; i < num_nodes - 1; ++i) {
        int u_val, v_val;
        std::cin >> u_val >> v_val;
        edges[i] = {u_val, v_val};
    }

    long long result = CalculateMaxFlow(num_nodes, edges);
    std::cout << result;
    return 0;
}
