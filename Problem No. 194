/*
Link: https://codeforces.com/contest/1278/problem/F

Kylie is conducting an experiment with a deck of cards. The deck consists of column_count cards, and exactly one card is a joker. Kylie performs the following
experiment row_count times: she shuffles the deck, takes the top card of the deck, looks at it, and then returns it into the deck.

Let x_count be the number of times Julie takes the joker out of the deck during this experiment. Assuming that every time Julie shuffles the deck, 
all column_count! possible permutations of cards are equally probable, what is the expected value of x_count^k_value? Print the answer modulo 998244353.

Create a C++ function CalculateExpectedValue that will return an integer denoting the expected value of x_count^k_value modulo 998244353.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

An integer row_count denoting the number of times Julie performs the experiment
An integer column_count denoting the number of cards in the deck
An integer k_value denoting the exponent

Input Constraints

The value of row_count should be in the range [1, 998244352] inclusive.
The value of column_count should be in the range [1, 998244352] inclusive.
The value of k_value should be in the range [1, 5000] inclusive.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>


int CalculatePower(int base, int exponent) {
    
    int result = 1;
    int modulus = 998244353;
  
    while (exponent) {
        if (exponent & 1) {
            result = static_cast<long long>(result) * base % modulus;
        }
        exponent >>= 1;
        base = static_cast<long long>(base) * base % modulus;
    }
    return result;
}

int CalculateExpectedValue (int row_count, int column_count, int k_value) {
  
    const int modulus = 998244353; 
  
    if (row_count < 1 || row_count >= modulus) {
        throw std::invalid_argument("row_count is out of bounds");
    }
    if (column_count < 1 || column_count >= modulus) {
        throw std::invalid_argument("column_count is out of bounds");
    }
    if (k_value < 1 || k_value > 5000) {
        throw std::invalid_argument("k_value is out of bounds");
    }
    
    std::vector<std::vector<int>> dp_table(k_value + 1, std::vector<int>(k_value + 1, 0));
    dp_table[0][0] = 1;

    for (int i = 1; i <= k_value; ++i) {
        for (int j = 1; j <= i; ++j) {
            dp_table[i][j] = (static_cast<long long>(dp_table[i - 1][j]) * j + static_cast<long long>(dp_table[i - 1][j - 1]) * (row_count - (j - 1))) % modulus;
        }
    }

    int result = 0;
    for (int i = 1; i <= k_value; ++i) {
        result = (static_cast<long long>(dp_table[k_value][i]) * CalculatePower(CalculatePower(column_count, i), modulus - 2) + result) % modulus;
    }

    return result;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    int row_count, column_count, k_value;
    std::cin >> row_count >> column_count >> k_value;

    try {
        int result = ComputeResult(row_count, column_count, k_value);
        std::cout << result << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid input: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

