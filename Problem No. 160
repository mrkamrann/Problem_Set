/*
Link:  https://codeforces.com/contest/542/problem/D

It's tough to be a superhero. And it's twice as tough to resist the supervillain who is cool at math. Suppose that you're an ordinary Batman in an ordinary city 
of Gotham. Your enemy Joker mined the building of the city administration and you only have several minutes to neutralize the charge. To do that, you should enter
the cancel code on the bomb control panel.

However, that mad man decided to give you a hint. This morning the mayor found a playing card under his pillow. There was a line written on the card:

The bomb has a note saying "J(x) = num", where num is some positive integer. You suspect that the cancel code is some integer x that meets the equation J(x) = num.
Now in order to decide whether you should neutralize the bomb or run for your life, you've got to count how many distinct positive integers x meet this equation.

You are given a single integer num.

Return the number of solutions of the equation J(x) = num.

Create a C++ Function CalculatePrimeFactorizations that will return an integer denoting the number of solutions of the equation J(x) = num.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An integer num

Input Constraints:

The value of num should be at least 1 and at most 10^12 inclusive.

*/

#include <stdio.h>
#include <stdexcept>
#include <cassert>
#include <vector>

bool IsPrime(long long number, const std::vector<int>& primes) {
    for (std::size_t j = 0;;) {
        long long current_prime = primes[j++];
        if ((current_prime * current_prime) > number) return true;
        if (!(number % current_prime)) return false;
    }
}

int CalculateFactorizations(int index, long long number, const std::vector<int>& primes) {
    if (number == 1) return 1;
    long long current_prime = primes[index];
    if ((current_prime + 1) > number) return 0;
    if (((current_prime * current_prime) + 1) > number) return IsPrime(--number, primes) ? 1 : 0;
    int result = CalculateFactorizations(index + 1, number, primes);
    for (;;) {
        if (++current_prime > number) return result;
        if (!(number % current_prime)) result += CalculateFactorizations(index + 1, number / current_prime, primes);
        current_prime = (current_prime - 1) * primes[index];
    }
}

std::vector<int> InitializePrimes() {
    std::vector<int> primes;
    primes.push_back(2);
    for (int i = 3; i < 1000010; i += 2) {
        if (IsPrime(i, primes)) {
            primes.push_back(i);
        }
    }
    return primes;
}

long long CalculatePrimeFactorizations(long long num) {

    if (num < 1 || num > 1000000000000LL) {
        throw std::invalid_argument("Invalid input: num must be between 1 and 1,000,000,000,000.");
    }

    std::vector<int> primes = InitializePrimes();
    return CalculateFactorizations(0, num, primes);
}

#include <stdio.h>
#include <stdexcept>
#include <cassert>
#include <vector>

int main() {
    long long number;
    scanf("%lld", &number);
    
    try {
        printf("%lld\n", CalculatePrimeFactorizations(number));
    } catch (const std::invalid_argument& e) {
        printf("Error: %s\n", e.what());
    }

    return 0;
}

