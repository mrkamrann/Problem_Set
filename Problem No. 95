/*
Link: https://codeforces.com/contest/452/problem/F

Julie is given a vector nums wihich a permutation of numbers from 1 to len. She needs to determine whether there exists a pair of integers a and b 
(1 ≤ a, b ≤ len and a!=b) such that the element (a+b)/2 appears between a and b in this permutation.

Note: This is regular division, not integer division

Create a C++ Function CheckPermutation that will return a boolean indicating whether such a pair exists.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

A vector<int> named permutation representing the nums itself.

Input Constraints

The value of len must be at least 1 and at most 300000 inclusive.
nums must contain exactly n integers, each integer being unique and ranging from 1 to len inclusive.

*/

#include <vector>
#include <unordered_map>
#include <stdexcept>
#include <cassert>


    bool CheckPermutation(std::vector<int>& nums) {
      
        int len = nums.size();
        
        if (len < 1 || len > 300000) {
            throw std::invalid_argument("Invalid input: nums size must be at least 2 and atmost 300000");
        }
      
        std::unordered_set<int> seen;

    for (int num : nums) {
        if (num < 1 || num > len || seen.count(num) > 0) {
            throw std::invalid_argument("nums is not a permutation.");
        }
        seen.insert(num);
    }

        int temp_value, condition_met;
        std::unordered_map<int, int> position_map;

        for (int index = 0; index < len; ++index) {
            position_map[nums[index]] = index + 1;
        }

        for (int i = 0; i < len; ++i) {
            for (int j = i + 1; j < std::min(len, i + 5); ++j) {
                temp_value = 2 * nums[j] - nums[i];
                if (temp_value <= len && temp_value > 0 && position_map[temp_value] > j + 1) {
                    condition_met = 1;
                    break;
                } else {
                    condition_met = 0;
                }
                temp_value = 2 * nums[i] - nums[j];
                if (temp_value <= len && temp_value > 0 && position_map[temp_value] < i + 1) {
                    condition_met = 1;
                    break;
                } else {
                    condition_met = 0;
                }
            }
            if (condition_met == 1) {
                break;
            }
        }

        if (condition_met) {
            return true;
        }
        return false;
    }


int main() {
   

    return 0;
}
