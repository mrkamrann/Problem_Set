/*
Link: https://codeforces.com/contest/1016/problem/G

Nikhil would like to form a team from two or three participants for the next season. There are num_candidates candidates, and the i-th candidate has rank a_i. 
However, Nikhil has some specific requirements for his teammates: if Nikhil has rank v and has chosen the i-th and j-th candidate, then GCD(v, a_i) = x_val and 
LCM(v, a_j) = y_val must be met.

Nikhil can change his rank to any non-negative integer, but x_val and y_val are tied to his birthdate and are fixed.

Nikhil wants to know how many pairs (i, j) exist such that there is an integer v meeting the following constraints: GCD(v, a_i) = x_val and LCM(v, a_j) = y_val. 
It is possible that i = j and Nikhil forms a team of two.

GCD is the greatest common divisor of two numbers, and LCM is the least common multiple.

You are given three integers num_candidates, x_val, and y_val  — the number of candidates and corresponding constants.
Also you are provided num_candidates integers a_1, a_2, ..., a_n  — ranks of candidates denoted by ranks

Return the only number — the number of pairs (i, j) such that there exists an integer v meeting the following constraints: 
GCD(v, a_i) = x_val and LCM(v, a_j) = y_val. It is possible that i = j.

Create a C++ function CountValidPairs that will return a long long denoting the number of valid pairs (i, j). 
Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An integer denoting num_candidates
A long long denoting x_val
A long long denoting y_val
vector<long long> &ranks

Input Constraints:

The length of ranks should be at least 1 and at most 2⋅10^5 inclusive.
Each value of ranks[i] should be in the range [1, 10^18] inclusive.
The values for x_val and y_val should be in the range [1, 10^18] inclusive.

*/

#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>
#include <cassert>
#include <numeric>

void Divide(long long number, std::vector<long long> &primes) {

    for (long long i = 2; i * i <= number; ++i) {
        if (number % i == 0) {
            primes.push_back(i);
            while (number % i == 0) {
                number /= i;
            }
        }
    }
    if (number > 1) {
        primes.push_back(number);
    }
}

long long CountValidPairs(int num_candidates, long long x_val, long long y_val, const std::vector<long long> &ranks) {

    if (num_candidates < 1 || num_candidates > 200000) {
        throw std::invalid_argument("Invalid number of candidates");
    }
    if (x_val < 1 || x_val > 1000000000000000000LL) {
        throw std::invalid_argument("Invalid x value");
    }
    if (y_val < 1 || y_val > 1000000000000000000LL) {
        throw std::invalid_argument("Invalid y value");
    }
    if (x_val > y_val) {
        throw std::invalid_argument("x value must be less than or equal to y value");
    }

    for (const auto &rank : ranks) {
        if (rank < 1 || rank > 1000000000000000000LL) {
            throw std::invalid_argument("Invalid rank value");
        }
    }

    if (y_val % x_val != 0) {
        return 0;
    }

    std::map<long long, int> gcd_counts_x, gcd_counts_y;

    for (int i = 0; i < num_candidates; ++i) {
        if (ranks[i] % x_val == 0) {
            ++gcd_counts_x[std::gcd(y_val / x_val, ranks[i] / x_val)];
        }
        if (y_val % ranks[i] == 0) {
            ++gcd_counts_y[y_val / ranks[i]];
        }
    }

    long long result = 0;

    if (gcd_counts_x.size() < 6000000 / gcd_counts_y.size()) {
        for (const auto &gcd_x : gcd_counts_x) {
            for (const auto &gcd_y : gcd_counts_y) {
                if (std::gcd(gcd_x.first, gcd_y.first) == 1) {
                    result += static_cast<long long>(gcd_x.second) * gcd_y.second;
                }
            }
        }
        return result;
    }

    std::vector<long long> primes;
    Divide(y_val, primes);

    std::vector<int> prime_mask_count(1 << primes.size(), 0);

    for (int i = 0; i < num_candidates; ++i) {
        if (ranks[i] % x_val != 0) {
            continue;
        }
        long long gcd_value = std::gcd(ranks[i] / x_val, y_val / x_val);
        int mask = 0;
        for (std::size_t j = 0; j < primes.size(); ++j) {
            if (gcd_value % primes[j] == 0) {
                mask |= 1 << j;
            }
        }
        ++prime_mask_count[mask];
    }

    for (std::size_t i = 0; i < primes.size(); ++i) {
        for (int j = 0; j < (1 << primes.size()); ++j) {
            if (j & (1 << i)) {
                prime_mask_count[j] += prime_mask_count[j ^ (1 << i)];
            }
        }
    }

    for (int i = 0; i < num_candidates; ++i) {
        if (y_val % ranks[i] != 0) {
            continue;
        }
        long long quotient = y_val / ranks[i];
        int mask = 0;
        for (std::size_t j = 0; j < primes.size(); ++j) {
            if (quotient % primes[j] != 0) {
                mask |= 1 << j;
            }
        }
        result += prime_mask_count[mask];
    }

    return result;
}

#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>
#include <cassert>
#include <numeric>

int main() {

  //remove auto keywords
    int num_candidates;
    long long x_val, y_val;
    std::cin >> num_candidates >> x_val >> y_val;

    std::vector<long long> ranks(num_candidates);
    for (int i = 0; i < num_candidates; ++i) {
        std::cin >> ranks[i];
    }

    try {
        long long result = CalculatePairs(num_candidates, x_val, y_val, ranks);
        std::cout << result << std::endl;
    } catch (const std::invalid_argument &e) {
        std::cerr << e.what() << std::endl;
    }

    return 0;
}

