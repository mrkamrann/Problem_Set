/*
Link: https://codeforces.com/contest/1305/problem/F

Kavish is very angry at the other setters for using him as a theme! As a punishment, he forced them to solve the following problem:

You have a vector elements consisting of num_elements positive integers. An operation consists of choosing an element and either adding 1 to it or subtracting 1 
from it, such that the element remains positive. We say the vector is good if the greatest common divisor of all its elements is not 1. Find the minimum number of
operations needed to make the vector good.

Unable to match Kavish's intellect, the setters failed to solve the problem. Help them escape from Kavish's punishment!

Return a single integer — the minimum number of operations required to make the vector good.

Create a C++ function MakeVectorGood that will return an integer denoting the minimum number of operations required to make the vector good.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<long long> denoting elements.

Input Constraints:

The value of num_elements should be in the range [2, 2⋅10^5] inclusive.
The value of elements[i] should be in the range [1, 10^12] inclusive.
*/

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>

void Check(long long value, long long num_elements, std::vector<long long>& elements, long long& result) {
  
    long long count;
  
    for (long long divisor = 2; divisor * divisor <= value; ++divisor) {
        if (value % divisor == 0) {
            while (value % divisor == 0) value /= divisor;
            count = 0;
            for (int index = 0; index < num_elements; ++index) {
                if (elements[index] < divisor) {
                    count += divisor - elements[index];
                } else {
                    count += std::min(elements[index] % divisor, divisor - elements[index] % divisor);
                }
            }
            result = std::min(result, count);
        }
    }
    if (value > 1) {
        long long divisor = value;
        count = 0;
        for (long long index = 0; index < num_elements; ++index) {
            if (elements[index] < divisor) {
                count += divisor - elements[index];
            } else {
                count += std::min(elements[index] % divisor, divisor - elements[index] % divisor);
            }
        }
        result = std::min(result, count);
    }
}

long long CalculateMinOperations(long long num_elements, std::vector<long long>& elements) {
  
    if (num_elements < 2 || num_elements > 200000) {
        throw std::invalid_argument("Number of elements out of range (2 ≤ num_elements ≤ 200000).");
    }
  
    for (int index = 0; index < num_elements; ++index) {
    
        if (elements[index] < 1 || elements[index] > 1e12) {
            throw std::invalid_argument("Element value out of range (1 ≤ element ≤ 1e12).");
        }
    }

    long long result = 1e18;

    std::srand(20091207);
    std::random_shuffle(elements.begin(), elements.end());

    for (long long index = std::min(num_elements, 50LL); index > 0; --index) {
        Check(elements[index - 1] - 1, num_elements, elements, result);
        Check(elements[index - 1], num_elements, elements, result);
        Check(elements[index - 1] + 1, num_elements, elements, result);
    }

    assert(result <= num_elements);
    return result;
}

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>

int main() {
    long long num_elements;
    std::cin >> num_elements;

    if (num_elements < 2 || num_elements > 200000) {
        throw std::invalid_argument("Number of elements out of range (2 ≤ num_elements ≤ 200000).");
    }

    std::vector<long long> elements(num_elements);
    for (long long index = 0; index < num_elements; ++index) {
        std::cin >> elements[index];
        if (elements[index] < 1 || elements[index] > 1e12) {
            throw std::invalid_argument("Element value out of range (1 ≤ element ≤ 1e12).");
        }
    }

    long long result = CalculateMinOperations(num_elements, elements);
    std::cout << result << std::endl;

    return 0;
}
