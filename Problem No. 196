/*
Link: https://codeforces.com/problemset/problem/1835/C

Famous worldwide astrophysicist Benjamin Lincoln recently read about the existence of twin galaxy clusters. Before he shares this knowledge with the broader 
audience in his podcast called S.tarT-ok, he wants to prove their presence on his own. Benjamin is aware that the vastness of the universe is astounding 
(almost as astounding as his observation skills) and decides to try his luck and find some new pair of twin clusters.

To do so, he used his telescope to observe a part of the night sky that was not yet examined by humanity in which there are exactly 2 * bits + 1 galaxies in a row.
Each of them consists of exactly 0 â‰¤ vec[i] < 4 * bits stars.

A galaxy cluster is any non-empty contiguous segment of galaxies. Moreover, its trait is said to be equal to the bitwise XOR of all values in vec within this range.

Two galaxy clusters are considered twins if and only if they have the same traits and their corresponding segments are disjoint.

Create a C++ function FindTwinClusters that will return a vector<long long> denoting the location of two intervals belonging to some twin clusters pair, or a single value -1 if no such pair 
exists.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

An integer bits denoting the value of k
A vector of integers vec representing the stars in each galaxy

Input Constraints

The value of bits should be in the range [0, 17] inclusive.
The length of vec should be 2 * bits + 1.
The sum of values 2 * bits + 1 over all test cases does not exceed 218.
Each value in vec should be in the range [0, 4 * bits] inclusive.


*/

#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>
#include <random>


std::vector<long long> FindTwinClusters(int bits, const std::vector<long long>& vec) {
    if (bits < 0 || bits > 17) {
        throw std::invalid_argument("bits must be between 0 and 17 inclusive.");
    }

    int size = 1 << (bits + 1);
    if (vec.size() != size) {
        throw std::invalid_argument("vec size does not match expected size.");
    }
    std::mt19937 random_gen(time(0));
    std::vector<long long> xor_prefix(size + 1, 0);
    std::map<long long, std::vector<long long>> prefix_map;
    
    for (int i = 1; i <= size; ++i) {
        xor_prefix[i] = vec[i - 1] ^ xor_prefix[i - 1];
        prefix_map[xor_prefix[i]].push_back(i);
    }
    
    while (true) {
        int x_val = random_gen() % (size + 1);
        int y_val = random_gen() % (size + 1);
        int z_val = random_gen() % (size + 1);
        
        for (long long w_val : prefix_map[xor_prefix[x_val] ^ xor_prefix[y_val] ^ xor_prefix[z_val]]) {
            std::vector<long long> result = {x_val, y_val, z_val, w_val};
            std::sort(result.begin(), result.end());
            if (result[0] < result[1] && result[2] < result[3]) {
                return {result[0] + 1, result[1], result[2] + 1, result[3]};
            }
        }
    }
}


#include <bits/stdc++.h>
#include <stdexcept>
#include <cassert>
#include <random>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    long long test_cases;
    std::cin >> test_cases;

    if (test_cases < 1) {
        throw std::invalid_argument("test_cases should be at least 1.");
    }

    for (long long t = 0; t < test_cases; ++t) {
        int bits;
        std::cin >> bits;

        int size = 1 << (bits + 1);
        std::vector<long long> vec(size);
        for (int i = 0; i < size; ++i) {
            std::cin >> vec[i];
        }

        try {
            std::vector<long long> result = Solve(bits, vec);
            for (std::vector<long long>::iterator it = result.begin(); it != result.end(); ++it) {
                std::cout << *it << " ";
            }
            std::cout << std::endl;
        } catch (const std::invalid_argument& e) {
            std::cerr << "Invalid input: " << e.what() << std::endl;
            return 1;
        }
    }

    return 0;
}

