/*
Link: https://codeforces.com/contest/1781/problem/F

Julie likes playing with bracket sequences. Today she wants to create a new bracket sequence using the following algorithm. Initially, Julie's sequence is an empty
string, and then she will repeat the following actions operations times:

Choose a place in the current bracket sequence to insert new brackets uniformly at random. If the length of the current sequence is k, then there are k+1 such 
places: before the first bracket, between the first and the second brackets, â€¦ , after the k-th bracket. In particular, there is one such place in an empty bracket sequence.
Choose string "()" with probability probability or string ")(" with probability 1 - probability and insert it into the chosen place. The length of the bracket s
equence will increase by 2.
A bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into it. For example, sequences 
"(())()", "()", and "(()(()))" are regular, while ")(", "(()", and "(()))(" are not.

Julie wants to know the probability that her bracket sequence will be a regular one at the end. Help her and find this probability modulo 998244353.

Create a C++ function CalculateRegularBracketProbability that will return an integer denoting the probability that the final bracket sequence will be regular, 
modulo 998244353.

Use appropriate error handling using the std::invalid_argument library for invalid test cases.

Input Type

An integer denoting operations
An integer denoting probability

Input Constraints

The value of operations should be at least 1 and at most 500 inclusive.
The value of probability should be at least 0 and at most 10,000 inclusive.
*/
#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>


std::vector<int> ComputeInverses(int max_val) {
    const long long mod_value = 998244353;
    std::vector<int> inverses(max_val + 1);
    inverses[1] = 1;
    for (int i = 2; i <= max_val; ++i) {
        inverses[i] = 1LL * (mod_value - mod_value / i) * inverses[mod_value % i] % mod_value;
    }
    return inverses;
}

int CalculateRegularBracketProbability(int num_seats, int passengers) {

    if (num_seats < 1 || num_seats > 500) {
        throw std::invalid_argument("Invalid number of seats. Must be between 1 and 500.");
    }
    if (passengers < 0 || passengers > 10000) {
        throw std::invalid_argument("Invalid number of passengers. Must be between 0 and 10000.");
    }
    const long long mod_value = 998244353;
    std::vector<int> inverses = ComputeInverses(10000);
    passengers = 1LL * passengers * inverses[10000] % mod_value;

    std::vector<std::vector<int>> dp_table(num_seats + 1, std::vector<int>(num_seats + 1, 0));

    for (int i = 0; i <= num_seats; ++i) {
        dp_table[0][i] = 1;
    }

    for (int i = 1; i <= num_seats; ++i) {
        for (int j = 0; j <= num_seats - i; ++j) {
            for (int k = 1; k <= i; ++k) {
                dp_table[i][j] = (dp_table[i][j] + (1LL * passengers * dp_table[k - 1][j + 1] + (j ? 1LL * (mod_value + 1 - passengers) * dp_table[k - 1][j - 1] : 0)) % mod_value * dp_table[i - k][j] % mod_value * inverses[k]) % mod_value;
            }
        }
    }

    int result = dp_table[num_seats][0];
    for (int i = 2; i <= num_seats; ++i) {
        result = 1LL * result * i % mod_value * inverses[(i << 1) - 1] % mod_value;
    }

    return result;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    int num_seats;
    int passengers;
    
    std::cin >> num_seats >> passengers;

    try {
        std::cout << ComputeAnswer(num_seats, passengers) << '\n';
    } catch (const std::invalid_argument& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
