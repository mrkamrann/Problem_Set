/*
Link: https://codeforces.com/contest/1781/problem/F
*/
#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>


std::vector<int> ComputeInverses(int max_val) {
    const long long mod_value = 998244353;
    std::vector<int> inverses(max_val + 1);
    inverses[1] = 1;
    for (int i = 2; i <= max_val; ++i) {
        inverses[i] = 1LL * (mod_value - mod_value / i) * inverses[mod_value % i] % mod_value;
    }
    return inverses;
}

int ComputeAnswer(int num_seats, int passengers) {

    if (num_seats < 1 || num_seats > 500) {
        throw std::invalid_argument("Invalid number of seats. Must be between 1 and 500.");
    }
    if (passengers < 0 || passengers > 10000) {
        throw std::invalid_argument("Invalid number of passengers. Must be between 0 and 10000.");
    }
    const long long mod_value = 998244353;
    std::vector<int> inverses = ComputeInverses(10000);
    passengers = 1LL * passengers * inverses[10000] % mod_value;

    std::vector<std::vector<int>> dp_table(num_seats + 1, std::vector<int>(num_seats + 1, 0));

    for (int i = 0; i <= num_seats; ++i) {
        dp_table[0][i] = 1;
    }

    for (int i = 1; i <= num_seats; ++i) {
        for (int j = 0; j <= num_seats - i; ++j) {
            for (int k = 1; k <= i; ++k) {
                dp_table[i][j] = (dp_table[i][j] + (1LL * passengers * dp_table[k - 1][j + 1] + (j ? 1LL * (mod_value + 1 - passengers) * dp_table[k - 1][j - 1] : 0)) % mod_value * dp_table[i - k][j] % mod_value * inverses[k]) % mod_value;
            }
        }
    }

    int result = dp_table[num_seats][0];
    for (int i = 2; i <= num_seats; ++i) {
        result = 1LL * result * i % mod_value * inverses[(i << 1) - 1] % mod_value;
    }

    return result;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    int num_seats;
    int passengers;
    
    std::cin >> num_seats >> passengers;

    try {
        std::cout << ComputeAnswer(num_seats, passengers) << '\n';
    } catch (const std::invalid_argument& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
