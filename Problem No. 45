/*

Link : https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/

John, a resident of a village with a simple directed graph, faces a challenge involving a graph with ğ‘™ğ‘’ğ‘› nodes labeled from 0 to ğ‘™ğ‘’ğ‘› - 1. The graph, structured such 
that its edges are directed (forming a tree if bidirectional), requires John to determine the minimum number of edge reversals necessary for each  node ğ‘– (from 0 to ğ‘™ğ‘’ğ‘› - 1).

He's provided with an integer ğ‘™ğ‘’ğ‘› and a 2D integer vector edges, where edges[ğ‘–] = [ğ‘¢_ğ‘–, ğ‘£_ğ‘–] denotes a directed edge from node ğ‘¢_ğ‘– to node ğ‘£_ğ‘–.
Edge reversals invert the direction of an edge, transforming a directed edge from ğ‘¢_ğ‘– to ğ‘£_ğ‘– into an edge from ğ‘£_ğ‘– to ğ‘¢_ğ‘–.
John's task is to compute independently, for each node ğ‘–, the minimum number of edge reversals needed so that every other node can be reached starting from node ğ‘– 
via directed edges.
He must return an integer vector answer, where answer[ğ‘–] represents the minimum number of edge reversals required for node ğ‘– to ensure connectivity to all other 
nodes in the graph.
Create a C++ function MinEdgeReversals to assist John in devising an optimal strategy to solve this problem. 

Input Type:

An Integer denoting len
vector<vector<int>> denoting edges

Input Constraints:

1.The number of nodes len should be at least 2 and at most 10^5 inclusive.
2.The number of edges edges should be exactly len - 1.
3.Each edge edges[i] should consist of exactly 2 elements.
4.For each edge edges[i], 0 <= u_i = edges[i][0] < len.
5.For each edge edges[i], 0 <= v_i = edges[i][1] < len.
6.For each edge edges[i], u_i != v_i.

*/


