/*

Link : https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/

John, a resident of a village with a simple directed graph, faces a challenge involving a graph with 𝑙𝑒𝑛 nodes labeled from 0 to 𝑙𝑒𝑛 - 1. The graph, structured such 
that its edges are directed (forming a tree if bidirectional), requires John to determine the minimum number of edge reversals necessary for each  node 𝑖 (from 0 to 𝑙𝑒𝑛 - 1).

He's provided with an integer 𝑙𝑒𝑛 and a 2D integer vector edges, where edges[𝑖] = [node𝑢_𝑖, node𝑣_𝑖] denotes a directed edge from node𝑢_𝑖 to node𝑣_𝑖.
Edge reversals invert the direction of an edge, transforming a directed edge from node𝑢_𝑖 to node𝑣_𝑖 into an edge from node𝑣_𝑖 to node𝑢_𝑖.
John's task is to compute independently, for each node 𝑖, the minimum number of edge reversals needed so that every other node can be reached starting from node 𝑖 
via directed edges.
He must return an integer vector answer, where answer[𝑖] represents the minimum number of edge reversals required for node 𝑖 to ensure connectivity to all other 
nodes in the graph.
Create a C++ function MinEdgeReversals to assist John in devising an optimal strategy to solve this problem. 

Input Type:

An Integer denoting len
vector<vector<int>> denoting edges

Input Constraints:

1.The number of nodes len should be at least 2 and at most 10^5 inclusive.
2.The number of edges edges should be exactly len - 1.
3.Each edge edges[i] should consist of exactly 2 elements.
4.For each edge edges[i], 0 <= nodeu_i = edges[i][0] < len.
5.For each edge edges[i], 0 <= nodev_i = edges[i][1] < len.
6.For each edge edges[i], nodeu_i != nodev_i.

*/

#include <vector>
#include <unordered_map>
#include <stdexcept>
#include <iostream>
#include <cassert>

    int CalculateInitialReversals(int node, std::vector<std::unordered_map<int, int>>& adjacency_map, std::vector<std::vector<int>>& adjacency_list, std::vector<int>& visited) {
        int reversals = 0;
        for (int i = 0; i < adjacency_list[node].size(); i++) {
            int next_node = adjacency_list[node][i];
            if (!visited[next_node]) {
                if (adjacency_map[next_node].count(node))
                    reversals++;
                visited[next_node] = 1;
                reversals += CalculateInitialReversals(next_node, adjacency_map, adjacency_list, visited);
            }
        }
        return reversals;
    }

    void CalculateReversals(int node, int previous_node, std::vector<std::unordered_map<int, int>>& adjacency_map, std::vector<std::vector<int>>& adjacency_list, std::vector<int>& visited, std::vector<int>& results) {
        visited[node] = 1;
        if (adjacency_map[previous_node].count(node))
            results[node] = results[previous_node] + 1;
        else
            results[node] = results[previous_node] - 1;
        for (int i = 0; i < adjacency_list[node].size(); i++) {
            int next_node = adjacency_list[node][i];
            if (!visited[next_node]) {
                CalculateReversals(next_node, node, adjacency_map, adjacency_list, visited, results);
            }
        }
    }

    std::vector<int> MinEdgeReversals(int len, std::vector<std::vector<int>>& edges) {
        if (len < 2 || len > 100000) {
            throw std::invalid_argument("The number of nodes len should be at least 2 and at most 100000 inclusive.");
        }
        if (edges.size() != len - 1) {
            throw std::invalid_argument("The number of edges should be exactly len - 1.");
        }

        std::vector<std::unordered_map<int, int>> adjacency_map(len);
        std::vector<std::vector<int>> adjacency_list(len);

        for (int i = 0; i < edges.size(); i++) {
            if (edges[i].size() != 2) {
                throw std::invalid_argument("Each edge should consist of exactly 2 elements.");
            }

            int node_u = edges[i][0];
            int node_v = edges[i][1];

            if (node_u < 0 || node_u >= len || node_v < 0 || node_v >= len) {
                throw std::invalid_argument("Each edge nodes should be in the range [0, len - 1].");
            }

            if (node_u == node_v) {
                throw std::invalid_argument("The nodes in each edge should be distinct.");
            }

          

            adjacency_map[node_u][node_v] = 1;
            adjacency_list[node_u].push_back(node_v);
            adjacency_list[node_v].push_back(node_u);
        }

        std::vector<int> results(len, 0);
        std::vector<int> visited(len, 0);

        visited[0] = 1;
        results[0] = CalculateInitialReversals(0, adjacency_map, adjacency_list, visited);

        visited = std::vector<int>(len, 0);
        visited[0] = 1;

        for (int i = 0; i < adjacency_list[0].size(); i++) {
            CalculateReversals(adjacency_list[0][i], 0, adjacency_map, adjacency_list, visited, results);
        }

        return results;
    }



int main(){
  return 0;
}
