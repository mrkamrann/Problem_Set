/*
Link : https://codeforces.com/contest/329/problem/E

Given a problem where there are city_count cities represented on a Cartesian plane by their coordinates in a 2D vector called coordinates, 
where coordinates[i] = [x_i, y_i], we need to compute the longest possible length of a Hamiltonian cycle among these cities. The distance between two 
cities is defined using the Manhattan distance. A Hamiltonian cycle of the cities is defined as a permutation of all n cities. The length of this Hamiltonian cycle
is defined as the sum of the distances between adjacent cities in the permutation plus the distance between the first and final city in the permutation. 

Return a single number denoting the longest possible length of a Hamiltonian cycle of the given cities.

Create a C++ function CalculateDistance that will return a long long  denoting the longest possible length of a Hamiltonian cycle.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<vector<int>> denoting coordinates

Input Constraints:

The value of city_count should be at least 3 and at most 100000 inclusive.
Each value of coordinates[i][0] and coordinates[i][1] should be in the range [0, 10^9] inclusive.
All given coordinates[i] will be distinct

*/

  


#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>

long long CalculateDistance(const std::vector<std::vector<long long>> &coordinates) {
   
    if (city_count < 3 || city_count > 100000) {
        throw std::invalid_argument("City count must be between 3 and 100000");
    }


    int mid = (city_count + 1) / 2;
    std::vector<long long> x_coord(city_count), y_coord(city_count);

    for (int i = 0; i < city_count; ++i) {
      
      if (coordinates[i][0] < 0 || coordinates[i][0] < 0 || coordinates[i][0] > 1e9 || coordinates[i][0] > 1e9) {
            throw std::invalid_argument("Coordinates must be non-negative and within [0, 1e9]");
        }
        x_coord[i] = coordinates[i][0];
        y_coord[i] = coordinates[i][1];
        
    }

    std::vector<long long> sorted_x = x_coord, sorted_y = y_coord;

    std::sort(sorted_x.begin(), sorted_x.end());
    std::sort(sorted_y.begin(), sorted_y.end());
  
    for (int i = 1; i < city_count; ++i) {
        if (sorted_x[i] == sorted_x[i - 1] && sorted_y[i] == sorted_y[i - 1]) {
            throw std::invalid_argument("All given points must be distinct");
        }
    }

    long long median_x = sorted_x[mid - 1];
    long long median_y = sorted_y[mid - 1];
    long long dir_x = sorted_x[mid] - sorted_x[mid - 1];
    long long dir_y = sorted_y[mid] - sorted_y[mid - 1];

    if (city_count % 2 == 1) {
        dir_x = std::min(dir_x, sorted_x[mid - 1] - sorted_x[mid - 2]);
        dir_y = std::min(dir_y, sorted_y[mid - 1] - sorted_y[mid - 2]);
    }

    long long total_distance = 0;
    bool quadrant_1 = false, quadrant_2 = false, central_point = false;

    for (int i = 0; i < city_count; ++i) {
      
        total_distance += std::abs(median_x - x_coord[i]) + std::abs(median_y - y_coord[i]);
        if (x_coord[i] > median_x && y_coord[i] <= median_y) {
            quadrant_1 = true;
        }
        if (x_coord[i] > median_x && y_coord[i] > median_y) {
            quadrant_2 = true;
        }
        if (x_coord[i] == median_x && y_coord[i] == median_y) {
            central_point = true;
        }
    }

    if ((city_count % 2 == 0) || central_point) {
        if (quadrant_1 && quadrant_2) {
            total_distance = std::max(total_distance - dir_x, total_distance - dir_y);
        }
    }

    return total_distance * 2;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>

int main() {
  
    return 0;
}

