/*
Link: https://leetcode.com/problems/maximum-profit-in-job-scheduling/description/

Jimmy was a young programmer, always eager to solve new challenges. One day, he came across an interesting problem involving job scheduling.

Jimmy was given job_count jobs, where every job is scheduled to be done from start_time[i] to end_time[i], obtaining a profit of profit[i].

He was provided with three vectors: start_time, end_time, and profit. His task was to return the maximum profit he could achieve such that no two jobs in the 
subset have overlapping time ranges.

If he chose a job that ends at time X, he would be able to start another job that starts at time X.

Create a C++ Function JobScheduling that will return an integer denoting the maximum profit. 

Use appropriate Error Handling using the stdexcept library for the invalid test cases


Input Type:

A vector<int> denoting start_time.
A vector<int> denoting end_time.
A vector<int> denoting profit.

Input Constraints:

The length of start_time, end_time, and profit should all be equal, and between 1 and 5 * 10^4 inclusive.
Each element in start_time should be less than each corresponding element in end_time, and both should be between 1 and 10^9 inclusive.
Each element in profit should be between 1 and 10^4 inclusive.

*/


#include <vector>
#include <algorithm>
#include <stdexcept>
#include <cassert>
#include <cmath>


    int JobScheduling(std::vector<int>& start_time, std::vector<int>& end_time, std::vector<int>& profit) {
        
        if (start_time.size() != profit.size()  || start_time.size() != end_time.size() || end_time.size() != profit.size() || profit.size() > 50000 || profit.size() < 1) {
    throw std::invalid_argument("Invalid input: Sizes of start_time, end_time, and profit must be equal and between 1 and 50000 inclusive.");
}

for (int i = 0; i < start_time.size(); ++i) {
    if (start_time[i] >= end_time[i] || start_time[i] < 1 || end_time[i] > 1000000000 || end_time[i] < 1 ||start_time[i] > 1000000000) {
        throw std::invalid_argument("Invalid input: Each element in start_time should be less than its corresponding element in end_time, and both should be between 1 and 1000000000 inclusive.");
    }
}

for (int i = 0; i < profit.size(); ++i) {
    if (profit[i] < 1 || profit[i] > 10000) {
        throw std::invalid_argument("Invalid input: Each element in profit should be between 1 and 10000 inclusive.");
    }
}

        int len = start_time.size();
        
        std::vector<std::vector<int>> arr(len);
        
        for (int i = 0; i < len; i++)
        {
            int start = start_time[i];
            int end = end_time[i];
            int profitt = profit[i];
            arr[i] = {end, start, profitt};
        }
        
        std::sort(arr.begin(), arr.end());
        
        std::vector<int> dp_arr(len, 0);
        
        dp_arr[0] = arr[0][2];
        
        for (int i = 1; i < len; i++)
        {
            int include = arr[i][2];
            
            int low = 0;
            int high = len - 1;
            int last_idx = -1;
            
            while (low <= high)
            {
                int mid = low + (high - low) / 2;
                
                if (arr[mid][0] <= arr[i][1])
                {
                    last_idx = mid;
                    low = mid + 1;
                } 
                else {
                    high = mid - 1;
                }
            }
            
            if (last_idx != -1)
            {
                include += dp_arr[last_idx];
            }
            
            int exclude = dp_arr[i - 1];
            
            dp_arr[i] = std::max(include, exclude);
        }
        
        return dp_arr[len - 1];
    }


int main(){
  return 0;
}


