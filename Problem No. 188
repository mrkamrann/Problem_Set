/*
Link: https://codeforces.com/contest/1948/problem/F

You are given num_bags bags numbered from 1 to num_bags. The i-th bag contains gold_coins[i] golden coins and silver_coins[i] silver coins.

The value of a gold coin is 1. The value of a silver coin is either 0 or 1, determined for each silver coin independently (0 with probability 1/2, 1 with 
probability 1/2).

You have to answer num_queries independent queries. Each query is the following:

queries[j] = [l, r] Calculate the probability that the total value of coins in bags from l to r is strictly greater than the total value in all other bags.

Input:

The first line contains two integers num_bags and num_queries (1 ≤ num_bags, num_queries ≤ 3⋅10^5) — the number of bags and the number of queries, respectively.
The second line contains num_bags integers gold_coins[0], gold_coins[1], ..., gold_coins[num_bags-1] (0 ≤ gold_coins[i] ≤ 10^6) — the number of gold coins in each bag.
The third line contains num_bags integers silver_coins[0], silver_coins[1], ..., silver_coins[num_bags-1] (0 ≤ silver_coins[i] ≤ 10^6) — the number of silver coins in each bag.
The next num_queries lines contain queries. The j-th of the next num_queries lines contains two integers queries[j][0] and queries[j][1] (1 ≤ queries[j][0] ≤ queries[j][1] ≤ num_bags) —
- the description of the j-th query.

Output:

For each query, return one integer — the probability that the total value of coins in bags from l to r is strictly greater than the total value in all other bags, 
taken modulo 998244353.

Formally, the probability can be expressed as an irreducible fraction x/y. You have to print the value of x⋅y^−1 mod 998244353, where y^−1 is an integer such 
that y⋅y^−1 mod 998244353 = 1.

Create a C++ function CalculateProbability that will return a vector<long long> denoting the probability of the total value in the given range of bags being greater than 
the total value in all other bags.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type:

A vector<int> denoting gold_coins.
A vector<int> denoting silver_coins.
A vector<vector<int>> denoting queries.

Input Constraints:

Each value of gold_coins[i] should be in the range [0, 10^6] inclusive.
Each value of silver_coins[i] should be in the range [0, 10^6] inclusive.
The values for num_bags and num_queries should be in the range [1, 3⋅10^5] inclusive.
The sum of the vector gold_coins should not exceed 10^6.
The sum of the vector silver_coins should not exceed 10^6.
*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>



long long QuickPower(long long base, long long exponent) {
    long long result = 1;
    int modulus = 998244353;
    while (exponent) {
        if (exponent & 1) result = result * base % modulus;
        base = base * base % modulus;
        exponent >>= 1;
    }
    return result;
}

std::vector<long long> CalculateProbability(std::vector<int>& gold_coins, std::vector<int>& silver_coins, std::vector<std::vector<int>>& queries) {
 if (gold_coins.empty() || silver_coins.empty() || queries.empty()) {
        throw std::invalid_argument("Input vectors must not be empty.");
    }

    int num_bags = static_cast<int>(gold_coins.size());

    if (num_bags != static_cast<int>(silver_coins.size())) {
        throw std::invalid_argument("Gold and silver coins vectors must be of the same size.");
    }

    if (num_bags < 1 || num_bags > 300000) {
        throw std::invalid_argument("The number of bags must be between 1 and 300000.");
    }

    for (int i = 0; i < num_bags; ++i) {
        if (gold_coins[i] < 0 || gold_coins[i] > 1000000) {
            throw std::invalid_argument("Gold coins count must be between 0 and 1000000.");
        }
        if (silver_coins[i] < 0 || silver_coins[i] > 1000000) {
            throw std::invalid_argument("Silver coins count must be between 0 and 1000000.");
        }
    }

    int num_queries = static_cast<int>(queries.size());
  
    if (num_queries < 1 || num_queries > 300000) {
        throw std::invalid_argument("The number of queries must be between 1 and 300000.");
    }
    int modulus = 998244353;
  
    std::vector<int> prefix_gold(num_bags + 1, 0), prefix_silver(num_bags + 1, 0);
    for (int i = 1; i <= num_bags; i++) {
        prefix_gold[i] = gold_coins[i - 1];
        prefix_gold[i] += prefix_gold[i - 1];
    }
    for (int i = 1; i <= num_bags; i++) {
        prefix_silver[i] = silver_coins[i - 1];
        prefix_silver[i] += prefix_silver[i - 1];
    }
    
    std::vector<long long> sum(prefix_silver[num_bags] + 1);
    long long x = 1;
    sum[0] = 1;
    for (int i = 1; i <= prefix_silver[num_bags]; i++) {
        x = x * (prefix_silver[num_bags] - i + 1) % modulus * QuickPower(i, modulus - 2) % modulus;
        sum[i] = (sum[i - 1] + x) % modulus;
    }
    
    long long inv = QuickPower(QuickPower(2, prefix_silver[num_bags]), modulus - 2);
    std::vector<long long> answers;

    for (std::vector<int>& query : queries) {
        if (query.size() != 2 || query[0] < 1 || query[1] > num_bags || query[0] > query[1]) {
            throw std::invalid_argument("Invalid query parameters.");
        }
        int left = query[0], right = query[1];
        int w = prefix_silver[right] - prefix_silver[left - 1] - (prefix_gold[num_bags] - prefix_gold[right] * 2 + prefix_gold[left - 1] * 2) - 1;
        if (w < 0) {
            answers.push_back(0);
        } else {
            answers.push_back(sum[std::min(w, prefix_silver[num_bags])] * inv % modulus);
        }
    }
    return answers;
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
  
  
  int n, q;
    std::cin >> n >> q;
    
    std::vector<int> a(n), b(n);
    for (int i = 0; i < n; i++) {
        std::cin >> a[i];
      
    }
    for (int i = 0; i < n; i++) {
        std::cin >> b[i]; 
    }
  
    std::vector<std::vector<int>>vec;
  
    for(int i = 0;i<q;++i)
    {
      int l,r;
      std::cin>>l>>r;
      vec.push_back({l,r});
    }
    

    std::vector<long long> results = ProcessQueries(a,b,vec);

    for (long long result : results) {
        std::cout << result << " ";
    }
    std::cout << std::endl;

    return 0;
}
