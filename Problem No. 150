/*
Link: https://codeforces.com/contest/1063/problem/D

At the children's festival, children were dancing in a circle. When music stopped playing, the children were still standing in a circle. Then Steve remembered
that his parents gave him a candy box with exactly num_candies candies "Wilky May". Steve is not a greedy person, so he decided to present all his candies to his
friends in the circle. Steve knows that some of his friends have a sweet tooth and others do not. A friend with a sweet tooth takes out of the box two candies 
if the box has at least two candies, and otherwise takes one. The rest of Steve's friends always take exactly one candy from the box.

Before starting to give candies, Steve stepped out of the circle, and there were exactly num_friends people remaining there. Steve numbered his friends in a 
clockwise order with positive integers starting with 1 in such a way that index 1 was assigned to his best friend Roma.

Initially, Steve gave the box to the friend with number start_friend, and after that, each friend (starting from friend number start_friend) took candies 
from the box and passed the box to the next friend in clockwise order. The process ended with the friend number end_friend taking the last candy 
(or two, who knows) and the empty box. Please note that it is possible that some of Steve's friends took candy from the box several times, that is, the 
box could have gone several full circles before becoming empty.

Steve does not know which of his friends have a sweet tooth, but he is interested in the maximum possible number of friends that can have a sweet tooth. If the 
situation could not happen, and Steve has been proved wrong in his observations, please tell him about this.

You are given four integers num_friends, start_friend, end_friend, and num_candies  — the number of children in the circle, the number of 
the friend who was given a box with candies, the number of the friend who has taken the last candy, and the initial number of candies in the box respectively.

Return exactly one long long integer — the maximum possible number of sweet tooth among Steve's friends or "-1" if Steve is wrong.

Create a C++ Function CalculateMaximumSweetTooth that will return a long long denoting the maximum possible number of sweet tooth among Steve's 
friends or "-1" if Steve is wrong.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type

A long long integer denoting num_friends
A long long integer denoting start_friend
A long long integer denoting end_friend
A long long integer denoting num_candies

Input Constraints

The value of num_friends should be at least 1 and at most 10^11 inclusive.
The value of start_friend should be at least 1 and at most num_friends inclusive.
The value of end_friend should be at least 1 and at most num_friends inclusive.
The value of num_candies should be at least 1 and at most 10^11 inclusive.

*/

#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <cassert>

long long CalculateMaximumSweetTooth(long long num_friends, long long start_friend, long long end_friend, long long num_candies) {
  
    if (num_friends < 1 || num_friends > 100000000000) {
        throw std::invalid_argument("Invalid num_friends. Must be in the range 1 to 100000000000.");
    }
    if (start_friend < 1 || start_friend > num_friends) {
        throw std::invalid_argument("Invalid start_friend. Must be in the range 1 to num_friends.");
    }
    if (end_friend < 1 || end_friend > num_friends) {
        throw std::invalid_argument("Invalid end_friend. Must be in the range 1 to num_friends.");
    }
    if (num_candies < 1 || num_candies > 100000000000) {
        throw std::invalid_argument("Invalid num_candies. Must be in the range 1 to 100000000000.");
    }

    long long segment_length = (end_friend >= start_friend ? end_friend - start_friend + 1 : end_friend + num_friends - start_friend + 1) % num_friends;
    long long max_possible_sweet_tooth = -1;

    for (long long i = num_candies, j_ind, r_ind; i; i = j_ind) {
        j_ind = num_candies / (num_candies / i + 1);
        r_ind = num_candies / i;
        long long upper_bound = std::min(2 * num_friends, i);
        long long lower_bound = std::max(num_friends, j_ind + 1);
        upper_bound = std::min(upper_bound, std::min((2 * num_friends + num_candies - 2 * segment_length + 1) / (r_ind + 1), (num_candies - segment_length) / r_ind));
        lower_bound = std::max(lower_bound, (num_candies - 2 * segment_length + r_ind - 1) / r_ind);

        if (upper_bound >= lower_bound) {
            max_possible_sweet_tooth = std::max(max_possible_sweet_tooth, upper_bound);
        }
    }

    if (segment_length <= num_candies && num_candies <= segment_length * 2) {
        max_possible_sweet_tooth = std::max(max_possible_sweet_tooth, num_friends + std::min(num_candies - segment_length, segment_length - 1) + num_friends - segment_length + 1);
    }

    if (!segment_length && num_candies == num_friends) {
        max_possible_sweet_tooth = std::max(max_possible_sweet_tooth, num_friends + 1);
    }

    if (max_possible_sweet_tooth == -1) {
        return -1;
    } else {
        return max_possible_sweet_tooth - num_friends;
    }
}

#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <cassert>

int main() {
    

    return 0;
}

