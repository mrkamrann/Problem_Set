/*
Link: https://codeforces.com/contest/1845/problem/F

There is a pool of length len where num_swimmers plan to swim. People start swimming at the same time (at the time moment 0), but you can assume that they take 
different lanes, so they don't interfere with each other.

Each person swims along the following route: they start at point 0 and swim to point len with constant speed (which is equal to speeds[i] units per second for the 
i-th swimmer). After reaching the point len, the swimmer instantly (in negligible time) turns back and starts swimming to the point 0 with the same constant speed.
After returning to the point 0, the swimmer starts swimming to the point len, and so on.

Let's say that some real moment of time is a meeting moment if there are at least two swimmers that are in the same point of the pool at that moment of time 
(that point may be 0 or len as well as any other real point inside the pool).

The pool will be open for duration seconds. You have to calculate the number of meeting moments while the pool is open. 
Since the answer may be very large, print it modulo 1000000007.

You are given two integers len and duration  — the length of the pool and the duration of the process (in seconds).

And a vector speed containing num_swimmers integers speeds[0], speeds[1], …, speeds[num_swimmers-1] , where speeds[i] is the speed of the i-th swimmer.
All speeds are pairwise distinct.

Return one integer — the number of meeting moments (including moment duration if needed and excluding moment 0), taken modulo 1000000007.

Create a C++ Function CalculateMeetingMoments that will return an integer denoting the number of meeting moments modulo 1,000,000,007.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An integer len
An integer duration
A vector<int> speeds

Input Constraints:

The value of len should be at least 1 and at most 10^9 inclusive.
The value of duration should be at least 1 and at most 10^9 inclusive.
The value of num_swimmers should be at least 2 and at most 2×10^5 inclusive.
Each value of speeds[i] should be at least 1 and at most 2×10^5 inclusive.
All speeds are pairwise distinct.

*/

#include <iostream>
#include <vector>
#include <set>
#include <stdexcept>
#include <cassert>

int ModularExponentiation(int base, int exponent, int modulus) {
    int result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1) {
            result = static_cast<int>(static_cast<long long>(result) * base % modulus);
        }
        base = static_cast<int>(static_cast<long long>(base) * base % modulus);
        exponent /= 2;
    }
    return result;
}

void NumberTheoreticTransform(std::vector<int>& vec, int transform_type) {

    const int modulus = 998244353;
    const int generator = 3;
    const int inverse_generator = 332748118;

    int size = static_cast<int>(vec.size());
    std::vector<int> reverse_indices(size);

    for (int i = 0; i < size; ++i) {
        reverse_indices[i] = (reverse_indices[i >> 1] >> 1) + ((i & 1) * (size >> 1));
    }

    for (int i = 0; i < size; ++i) {
        if (i < reverse_indices[i]) {
            std::swap(vec[i], vec[reverse_indices[i]]);
        }
    }

    for (int t = 0; t < 19; ++t) {
        int root = ModularExponentiation(transform_type == 1 ? generator : inverse_generator, (modulus - 1) >> (t + 1), modulus);
        int segment_length = 1 << t;

        for (int i = 0; i < size; i += segment_length * 2) {
            for (int j = 0, w_val = 1; j < segment_length; ++j, w_val = static_cast<int>(static_cast<long long>(w_val) * root % modulus)) {
                int x_val = vec[i + j];
                int y_val = static_cast<int>(static_cast<long long>(vec[i + segment_length + j]) * w_val % modulus);

                vec[i + j] = x_val + y_val < modulus ? x_val + y_val : x_val + y_val - modulus;
                vec[i + segment_length + j] = x_val - y_val >= 0 ? x_val - y_val : x_val - y_val + modulus;
            }
        }
    }

    if (transform_type == -1) {
        int inverse_size = ModularExponentiation(size, modulus - 2, modulus);
        for (int i = 0; i < size; ++i) {
            vec[i] = static_cast<int>(static_cast<long long>(vec[i]) * inverse_size % modulus);
        }
    }
}

int CalculateMeetingMoments(int len, int duration, const std::vector<int>& speeds) {

int num_swimmers = speeds.size();

if (len < 1 || len > 1000000000) {
    throw std::invalid_argument("Invalid length of the pool: must be between 1 and 1,000,000,000.");
}

if (duration < 1 || duration > 1000000000) {
    throw std::invalid_argument("Invalid duration: must be between 1 and 1,000,000,000 seconds.");
}

if (num_swimmers < 2 || num_swimmers > 200000) {
    throw std::invalid_argument("Invalid number of swimmers: must be between 2 and 200,000.");
}

for (int speed : speeds) {
    if (speed < 1 || speed > 200000) {
        throw std::invalid_argument("Invalid speed value: must be between 1 and 200,000.");
    }
}

std::set<int> unique_speeds(speeds.begin(), speeds.end());

if (unique_speeds.size() != speeds.size()) {
    throw std::invalid_argument("Speed values are not pairwise distinct.");
}


    const int modulus = 998244353;
    const int max_index = 200000;
    const int ntt_size = 1 << 19;

    std::vector<int> a_vec(ntt_size, 0);
    std::vector<int> b_vec(ntt_size, 0);

    for (int speed : speeds) {
        a_vec[speed]++;
        b_vec[max_index - speed]++;
    }

    NumberTheoreticTransform(a_vec, 1);
    NumberTheoreticTransform(b_vec, 1);

    for (int i = 0; i < ntt_size; ++i) {
        b_vec[i] = static_cast<int>(static_cast<long long>(b_vec[i]) * a_vec[i] % modulus);
        a_vec[i] = static_cast<int>(static_cast<long long>(a_vec[i]) * a_vec[i] % modulus);
    }

    NumberTheoreticTransform(a_vec, -1);
    NumberTheoreticTransform(b_vec, -1);

    for (int speed : speeds) {
        a_vec[speed * 2]--;
    }

    std::vector<bool> valid_speed(max_index * 2, false);
    std::vector<int> dp_table(max_index * 2, 0);
    int answer = 0;

    for (int i = 1; i < max_index * 2; ++i) {
        if (a_vec[i]) {
            valid_speed[i] = true;
        }
    }

    for (int i = 1; i < max_index; ++i) {
        if (b_vec[max_index + i]) {
            valid_speed[i] = true;
        }
    }

    for (int i = 1; i < max_index * 2; ++i) {
        for (int j = i + i; j < max_index * 2; j += i) {
            if (valid_speed[j]) {
                valid_speed[i] = true;
            }
        }
    }

    for (int i = 1; i < max_index * 2; ++i) {
        if (valid_speed[i]) {
            if ((dp_table[i] += static_cast<int>((static_cast<long long>(duration) * i / (len * 2) % 1000000007))) >= 1000000007)
                dp_table[i] -= 1000000007;
            for (int j = i + i; j < max_index * 2; j += i) {
                if ((dp_table[j] -= dp_table[i]) < 0)
                    dp_table[j] += 1000000007;
            }
            if ((answer += dp_table[i]) >= 1000000007)
                answer -= 1000000007;
        }
    }

    return answer;
}

#include <iostream>
#include <vector>
#include <set>
#include <stdexcept>
#include <cassert>

int main() {
    int len, duration, num_swimmers;
    std::cin >> len >> duration >> num_swimmers;

    std::vector<int> speeds(num_swimmers);
    for (int i = 0; i < num_swimmers; ++i) {
        std::cin >> speeds[i];
    }

    int answer = ComputeAnswer(len, duration, num_swimmers, speeds);
    std::cout << answer << std::endl;

    return 0;
}

