/*
Link: https://codeforces.com/contest/1709/problem/F

Aryan is fascinated by combinatorial problems and recently encountered an intriguing one involving binary strings.

Consider all binary strings (i.e., strings consisting of characters '0' and/or '1') of length from 1 to num_terms. For every such string s, you need to choose 
an integer c_s from 0 to max_value.

A multiset of binary strings of length exactly num_terms is considered beautiful if for every binary string s with length from 1 to num_terms, the number of 
strings in the multiset such that s is their prefix does not exceed c_s.

For example, let num_terms = 2, c_0 = 3, c_00 = 1, c_01 = 2, c_1 = 1, c_10 = 2, and c_11 = 3. The multiset of strings {11, 01, 00, 01} is beautiful, since:

For the string "0", there are 3 strings in the multiset such that "0" is their prefix, and 3 ≤ c_0.
For the string "00", there is one string in the multiset such that "00" is its prefix, and 1 ≤ c_00.
For the string "01", there are 2 strings in the multiset such that "01" is their prefix, and 2 ≤ c_01.
For the string "1", there is one string in the multiset such that "1" is its prefix, and 1 ≤ c_1.
For the string "10", there are 0 strings in the multiset such that "10" is their prefix, and 0 ≤ c_10.
For the string "11", there is one string in the multiset such that "11" is its prefix, and 1 ≤ c_11.

The problem itself is: Calculate the number of ways to choose the integer c_s for every binary string s of length from 1 to num_terms such that the maximum
possible size of a beautiful multiset is exactly result_index. Since it can be huge, print it modulo 998244353.

Create a C++ Function CalculateBeautifulMultisets that will return an long long denoting the number of ways to choose the integers c_s such that the maximum
possible size of a beautiful multiset is exactly result_index.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type

An integer denoting num_terms
An integer denoting max_value
An integer denoting result_index

Input Constraints

The value of num_terms should be at least 1 and at most 15 inclusive.
The value of max_value should be at least 1 and at most 200,000 inclusive.
The value of result_index should be at least 1 and at most 200,000 inclusive.
*/

#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <stdexcept>
#include <cassert>



long long QuickPow(long long base, long long exponent) {
    long long result = 1;
     long long root = 3;
long long modulus = 998244353;
    while (exponent) {
        if (exponent & 1) {
            result = result * base % modulus;
        }
        base = base * base % modulus;
        exponent >>= 1;
    }
    return result;
}

std::vector<long long> NttTransform(std::vector<long long> values, int operation, const std::vector<long long>& bit_reversal) {
    int total_size = static_cast<int>(values.size());
    long long root = 3;
long long modulus = 998244353;
    for (int i = 0; i < total_size; i++) {
        if (i < bit_reversal[i]) {
            std::swap(values[i], values[bit_reversal[i]]);
        }
    }
    for (int mid = 1; mid < total_size; mid <<= 1) {
        long long w_val = QuickPow((operation == 1 ? root : QuickPow(root, modulus - 2)), (modulus - 1) / (mid << 1));
        for (int i = 0; i < total_size; i += (mid << 1)) {
            long long wk_val = 1;
            for (int j = 0; j < mid; j++, wk_val = wk_val * w_val % modulus) {
                long long x_val  = values[i + j], y_val  = wk_val * values[i + j + mid] % modulus;
                values[i + j] = (x_val  + y_val ) % modulus;
                values[i + j + mid] = (x_val  - y_val  + modulus) % modulus;
            }
        }
    }
    if (operation == -1) {
        long long inv = QuickPow(total_size, modulus - 2);
        for (int i = 0; i < total_size; i++) {
            values[i] = values[i] * inv % modulus;
        }
    }
    return values;
}

std::vector<long long> MultiplyPolynomials(std::vector<long long> polynomial_a, std::vector<long long> polynomial_b, const std::vector<long long>& bit_reversal) {
  
    long long root = 3;
long long modulus = 998244353;
  
    polynomial_a = NttTransform(polynomial_a, 1, bit_reversal);
    polynomial_b = NttTransform(polynomial_b, 1, bit_reversal);
    int length = static_cast<int>(polynomial_a.size());
    for (int i = 0; i < length; i++) {
        polynomial_a[i] = polynomial_a[i] * polynomial_b[i] % modulus;
    }
    polynomial_a = NttTransform(polynomial_a, -1, bit_reversal);
    return polynomial_a;
}

std::vector<long long> PolynomialMultiply(std::vector<long long> polynomial_a, std::vector<long long> polynomial_b) {
    int size_a = static_cast<int>(polynomial_a.size()) - 1;
    int size_b = static_cast<int>(polynomial_b.size()) - 1;
    long long root = 3;
long long modulus = 998244353;
    int limit = 0;
    while ((1 << limit) <= (size_a + size_b + 1)) {
        limit++;
    }
    std::vector<long long> bit_reversal(1 << limit);
    for (int i = 1; i < (1 << limit); i++) {
        bit_reversal[i] = (bit_reversal[i >> 1] >> 1) | ((i & 1) << (limit - 1));
    }
    std::vector<long long> extended_a(1 << limit), extended_b(1 << limit);
    for (int i = 0; i <= size_a; i++) {
        extended_a[i] = polynomial_a[i];
    }
    for (int i = 0; i <= size_b; i++) {
        extended_b[i] = polynomial_b[i];
    }
    std::vector<long long> result = MultiplyPolynomials(extended_a, extended_b, bit_reversal);
    result.resize(size_a + size_b + 1);
    return result;
}

long long CalculateBeautifulMultisets(int num_terms, int max_value, int result_index) {
  
    if (num_terms < 1 || num_terms > 15) {
        throw std::invalid_argument("num_terms out of range");
    }
    if (max_value < 1 || max_value > 200000) {
        throw std::invalid_argument("max_value out of range");
    }
    if (result_index < 1 || result_index > 200000) {
        throw std::invalid_argument("result_index out of range");
    }

    long long root = 3;
long long modulus = 998244353;
  
    std::vector<std::vector<long long>> dp_table(num_terms + 1, std::vector<long long>(max_value + 1, 0));
    for (int i = 0; i <= max_value; i++) {
        dp_table[1][i] = 1;
    }
    for (int term = 2; term <= num_terms; term++) {
        std::vector<long long> polynomial(max_value + 1);
        for (int val = 0; val <= max_value; val++) {
            polynomial[val] = dp_table[term - 1][val];
        }
        polynomial = PolynomialMultiply(polynomial, polynomial);
        long long cumulative_sum = 0;
        for (int val = 2 * max_value; val >= 0; val--) {
            cumulative_sum = (cumulative_sum + polynomial[val]) % modulus;
            if (val <= max_value) {
                dp_table[term][val] = (cumulative_sum + (max_value - val) * polynomial[val] % modulus) % modulus;
            }
        }
    }
    std::vector<long long> final_polynomial(max_value + 1);
    for (int i = 0; i <= max_value; i++) {
        final_polynomial[i] = dp_table[num_terms][i];
    }
    final_polynomial = PolynomialMultiply(final_polynomial, final_polynomial);

    return ((result_index >= static_cast<int>(final_polynomial.size())) ? 0 : final_polynomial[result_index]);
}

#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <stdexcept>
#include <cassert>


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int num_terms, max_value, result_index;
    std::cin >> num_terms >> max_value >> result_index;

    long long result = Solve(num_terms, max_value, result_index);
    std::cout << result << std::endl;

    return 0;
}

