/*
Link : https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/

Julie is given an undirected graph of node_count nodes defined by edge_list, where edge_list[i] = [u_i, v_i, dis_i] denotes an edge between nodes u_i and v_i 
with distance dis_i. Note that there may be multiple edges between two nodes.

Julie is also given an array queries, where queries[j] = [p_j, q_j, limit_j]. Julie's task is to determine for each queries[j] whether there is a path between 
p_j and q_j such that each edge on the path has a distance strictly less than limit_j.

Return a boolean vector answer, where answer.length == queries.length and the j-th value of answer is true if there is a path for queries[j] is true, and false otherwise.

Create a C++ class Solution that will contain a function DistanceLimitedPathsExist that will return a vector<bool> denoting the vector answer.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type:

An integer denoting node_count
A vector<vector<int>> denoting edge_list
A vector<vector<int>> denoting queries

Input Constraints:

The values for node_count should be in the range [2, 10^5] inclusive.
The length of edge_list should be at least 1 and at most 10^5 inclusive.
The length of queries should be at least 1 and at most 10^5 inclusive.
Each value of edge_list[i][0] and edge_list[i][1] should be in the range [0, node_count - 1] inclusive.
Each value of queries[j][0] and queries[j][1] should be in the range [0, node_count - 1] inclusive.
Each value of edge_list[i][2] and queries[j][2] should be in the range [1, 10^9] inclusive.
The values u_i and v_i should be different.
The values p_j and q_j should be different.
*/

#include <vector>
#include <algorithm>
#include <stdexcept>
#include <cassert>
#include <iostream>

class DisjointSet {
private:
    std::vector<int> parent, size;

public:
    DisjointSet(int node_count) {
        parent.resize(node_count);
        size.resize(node_count);
        for(int node = 0; node < node_count; node++) {
            parent[node] = node;
            size[node] = 1;
        }
    }

    int FindParent(int node) {
        if(parent[node] == node) {
            return node;
        }
        parent[node] = FindParent(parent[node]);
        return parent[node];
    }

    void Union(int node_1, int node_2) {
        int parent_1 = FindParent(node_1);
        int parent_2 = FindParent(node_2);

        if(parent_1 == parent_2) {
            return;
        }

        if(size[parent_1] > size[parent_2]) {
            parent[parent_2] = parent_1;
            size[parent_1] += size[parent_2];
        } else {
            parent[parent_1] = parent_2;
            size[parent_2] += size[parent_1];
        }
    }
};

class Solution {
public:
  
    static bool Comparator(const std::vector<int>&vec_a, const std::vector<int>&vec_b) {
        return vec_a[2] <= vec_b[2];
    }

    std::vector<bool> DistanceLimitedPathsExist(int node_count, std::vector<std::vector<int>>& edge_list, std::vector<std::vector<int>>& queries) {
        if(node_count < 2 || node_count > 100000) {
            throw std::invalid_argument("node_count must be in the range [2, 100000]");
        }
        if(edge_list.size() < 1 || edge_list.size() > 100000) {
            throw std::invalid_argument("The length of edge_list must be in the range [1, 100000]");
        }
        if(queries.size() < 1 || queries.size() > 100000) {
            throw std::invalid_argument("The length of queries must be in the range [1, 100000]");
        }

        for(std::size_t i = 0; i < edge_list.size(); ++i) {
            if(edge_list[i][0] < 0 || edge_list[i][0] >= node_count || edge_list[i][1] < 0 || edge_list[i][1] >= node_count || edge_list[i][2] < 1 || edge_list[i][2] > 1000000000) {
                throw std::invalid_argument("Each value in edge_list[i] must be within the specified range");
            }
            if(edge_list[i][0] == edge_list[i][1]) {
                throw std::invalid_argument("Values u_i and v_i in edge_list must be different");
            }
        }

        for(std::size_t j = 0; j < queries.size(); ++j) {
            if(queries[j][0] < 0 || queries[j][0] >= node_count || queries[j][1] < 0 || queries[j][1] >= node_count || queries[j][2] < 1 || queries[j][2] > 1000000000) {
                throw std::invalid_argument("Each value in queries[j] must be within the specified range");
            }
            if(queries[j][0] == queries[j][1]) {
                throw std::invalid_argument("Values p_j and q_j in queries must be different");
            }
        }

        DisjointSet disjoint_set(node_count);
        for(std::size_t index = 0; index < queries.size(); ++index) {
            queries[index].push_back(index);
        }

        std::vector<bool> answer(queries.size(), false);
        std::sort(edge_list.begin(), edge_list.end(), Comparator);
        std::sort(queries.begin(), queries.end(), Comparator);

        int edge_index = 0;
        for(std::size_t query_index = 0; query_index < queries.size(); ++query_index) {
            while(edge_index < edge_list.size() && edge_list[edge_index][2] < queries[query_index][2]) {
                disjoint_set.Union(edge_list[edge_index][0], edge_list[edge_index][1]);
                edge_index++;
            }
            int parent_p = disjoint_set.FindParent(queries[query_index][0]);
            int parent_q = disjoint_set.FindParent(queries[query_index][1]);
            answer[queries[query_index][3]] = (parent_p == parent_q);
        }
        return answer;
    }
};

int main() {
  
  Solution solution;
    //TEST
   
    //TEST_END
    return 0;
}

