/*
Link : https://leetcode.com/problems/kth-smallest-amount-with-single-denomination-combination/description/

Julie has an integer vector coin_denominations that represents coins of different denominations and an integer target_index.

Julie has an infinite number of coins for each denomination in coin_denominations. However, she is not allowed to combine coins of different denominations to 
reach a target amount.

Julie wants to find the target_index-th smallest amount that can be made using these coins when considering each denomination separately.

Create a C++ function FindKthSmallest that will return an integer denoting the target_index-th smallest amount that can be made using these coins.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type:

vector<int> denoting coin_denominations
An integer denoting target_index

Input Constraints:

The length of coin_denominations (i.e., the number of different coin denominations) must be at least 1 and at most 15 inclusive.
Each value in coin_denominations must be between 1 and 25 inclusive.
All values in coin_denominations are distinct.
The value of target_index must be between 1 and 2 * 10^9 inclusive.

*/

#include <vector>
#include <algorithm>
#include <numeric>
#include <stdexcept>
#include <climits>
#include <cassert>
#include <limits>

    long long ComputeLcm(long long val_a, long long val_b) {
        return (val_a * val_b) / std::gcd(val_a, val_b);
    }
    
    long long FetchLcm(const std::vector<int>& coin_denominations, long long index) {
        long long lcm_value = 1;
        long long val = 0;
        while (index) {
            if (index & 1) {
                lcm_value = ComputeLcm(lcm_value, coin_denominations[val]);
            }
            val++;
            index >>= 1;
        }
        return lcm_value;
    }
    
    
    
    int CountSetBits(long long number) {
        int count = 0;
        while (number) {
            count += number & 1;
            number >>= 1;
        }
        return count;
    }


    long long FindPosition(long long num, const std::vector<int>& coin_denominations) {
        long long sum = 0;
        long long number_of_denominations = coin_denominations.size();
        
        for (long long i = 1; i <= ((1 << number_of_denominations) - 1); i++) {
            long long lcm_value = FetchLcm(coin_denominations, i);
            if (CountSetBits(i) % 2 == 1) {
                sum += num / lcm_value;
            } else {
                sum -= num / lcm_value;
            }
        }
        
        bool exists = true;
        for (long long coin : coin_denominations) {
            if (num % coin == 0) {
                exists = false;
                break;
            }
        }
        
        if (exists) sum++;
        return sum;
    }
    
    long long FindKthSmallest(std::vector<int>& coin_denominations, int target_index) {
       
        if (coin_denominations.size() < 1 || coin_denominations.size() > 15) {
            throw std::invalid_argument("coin_denominations length must be between 1 and 15 inclusive.");
        }
        for (int coin : coin_denominations) {
            if (coin < 1 || coin > 25) {
                throw std::invalid_argument("Each coin denomination must be between 1 and 25 inclusive.");
            }
        }
        if (target_index < 1 || target_index > 2'000'000'000) {
            throw std::invalid_argument("target_index must be between 1 and 2 * 10^9 inclusive.");
        }

        long long minimum_denomination = std::numeric_limits<long long>::max();

        for (long long value : coin_denominations)
        {
            if (value < minimum_denomination)
            {
                minimum_denomination = value;
            }
        }

        long long number_of_denominations = coin_denominations.size();

        long long minimum_range = static_cast<long long>(minimum_denomination) * (target_index / number_of_denominations);
        long long maximum_range = static_cast<long long>(minimum_denomination) * target_index;
        
        long long left = minimum_range;
        long long right = maximum_range;
        
        while (left <= right) {
            long long middle = (right - left) / 2 + left;
            long long position = FindPosition(middle, coin_denominations);
            
            if (position == target_index) {
                long long smallest_greater = LLONG_MAX;
                for (long long coin : coin_denominations) {
                    if (middle % coin == 0) return middle;
                    smallest_greater = std::min(smallest_greater, coin * (middle / coin + 1));
                }
                return smallest_greater;
            }
            if (position >= target_index) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return right;
    }

int main(){
  return 0;
}

