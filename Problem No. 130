/*
Link: https://codeforces.com/problemset/problem/1485/E

Raj is given num_vertices - 1 integers parent_2, parent_3, ..., parent_num_vertices and a tree with num_vertices vertices rooted at vertex 1. 
The leaves are all at the same distance d from the root.

Recall that a tree is a connected undirected graph without cycles. The distance between two vertices is the number of edges on the simple path between them.
All non-root vertices with degree 1 are leaves. If vertices s and f are connected by an edge and the distance of f from the root is greater than the distance of s from the root, then f is called a child of s.

Initially, there are a red coin and a blue coin on the vertex 1. Let r be the vertex where the red coin is and let b be the vertex where the blue coin is. 
Raj should make d moves. A move consists of three steps:

Move the red coin to any child of r.

Move the blue coin to any vertex b' such that dist(1, b') = dist(1, b) + 1. Here dist(x, y) indicates the length of the simple path between x and y. 

Note that b and b' are not necessarily connected by an edge. Raj can optionally swap the two coins (or skip this step).

Note that r and b can be equal at any time, and there is no number written on the root.

After each move, Raj gains |values_r - values_b| points. What's the maximum number of points Raj can gain after d moves?


Raj is given a single integer num_vertices  — the number of vertices in the tree.
num_vertices - 1 integers parent_2, parent_3, ..., parent_num_vertices — the i-th of them indicates that there is an edge between vertices i and parent_i. 
He is also given num_vertices - 1 integers values_2, ..., values_num_vertices  — the numbers written on the vertices.


Return a single number : the maximum number of points Raj can gain after d moves.

Create a C++ Function MaxPointsAfterMoves that will return an long long denoting the maximum number of points

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type:

A vector of integers denoting parent
A vector of integers denoting values

Input Constraints:

The length of num_vertices should be atleast 2 and should not exceed 2 * 10^5.
Each value of parent[i] should be in the range [1, num_vertices] inclusive, and parent_i ≠ i.
Each value of values[i] should be in the range [1, 10^9] inclusive.
The length of parent should be equal to values



*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
#include <stdexcept>
#include <cassert>


void DepthFirstSearch(int node, int depth, const std::vector<std::vector<int>>& edges, std::vector<std::vector<int>>& levels) {
    for (int val : edges[node]) {
        levels[depth].push_back(val);
        DepthFirstSearch(val, depth + 1, edges, levels);
    }
}

long long MaxPointsAfterMoves(const std::vector<int>& parent, const std::vector<int>& values) {
  
    int num_vertices = parent.size() + 1;
  
    if (num_vertices < 2 || num_vertices > 200000) {
        throw std::invalid_argument("num_vertices must be in the range [2, 200000]");
    }
    
    if (parent.size() != values.size()) {
        throw std::invalid_argument("size of both vectors should be equal");
    }
  
    
    int ind = 2;

    for (int parent_value : parent) {
        if (parent_value < 1 || parent_value > num_vertices || parent_value == ind) {
            throw std::invalid_argument("parent values must be in the range [1, num_vertices] and parent[i] should not be equal to i");
        }
        ind++;
    }
    int infinity = 1000000007;
    for (int value : values) {
        if (value < 1 || value > 1000000000) {
            throw std::invalid_argument("values must be in the range [1, 1000000000]");
        }
    }

    std::vector<std::vector<int>> edges(num_vertices + 1);
    std::vector<std::vector<int>> levels(num_vertices + 1);
    std::vector<long long> dp_table(num_vertices + 1, 0);
    long long answer = 0;

    for (int i = 0; i < num_vertices - 1; ++i) {
        edges[parent[i]].push_back(i + 2);
    }

    DepthFirstSearch(1, 1, edges, levels);

    for (int i = 1; !levels[i].empty(); ++i) {
        int max_value = 0, min_value = infinity;
        long long pos = 0, neg = -1 * infinity;

        for (int node : levels[i]) {
            max_value = std::max(max_value, values[node - 2]);
            min_value = std::min(min_value, values[node - 2]);
            pos = std::max(pos, dp_table[parent[node - 2]] + values[node - 2]);
            neg = std::max(neg, dp_table[parent[node - 2]] - values[node - 2]);
        }

        for (int node : levels[i]) {
            answer = std::max(answer, dp_table[node] = std::max({
                std::max(values[node - 2] - min_value, max_value - values[node - 2]) + dp_table[parent[node - 2]],
                pos - values[node - 2],
                neg + values[node - 2]
            }));
        }

        levels[i].clear();
    }

    return answer;
}


#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
#include <stdexcept>
#include <cassert>


int main() {
    

    return 0;
}

