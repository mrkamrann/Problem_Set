/*
Link : https://codeforces.com/problemset/problem/196/D

Alice needs to find a string with certain properties. The problem authors were reluctant to waste time thinking of a name for this string, so they called it good. 
A string is good if it doesn't have palindrome substrings longer than or equal to count.

Alice is given a string str, consisting only of lowercase English letters. Find a good string t with length |str|, consisting of lowercase English letters,
which is lexicographically larger than str. Of all such strings, t must be lexicographically minimum.

We will call a non-empty string str[a ... b] = str[a]str[a + 1]... str[b] (1 ≤ a ≤ b ≤ |str|) a substring of string str = str[1]str[2]... str[|str|].

A non-empty string str = str[1]str[2]... str[n] is called a palindrome if for all i from 1 to n the following fulfills: str[i] = str[n - i + 1]. In other words, 
a palindrome reads the same in both directions.

String x = x[1]x[2]... x[|x|] is lexicographically larger than string y = y[1]y[2]... y[|y|], if either |x| > |y| and x[1] = y[1], x[2] = y[2], ... , x[|y|] = y[|y|], 
or there exists such number r (r < |x|, r < |y|), that x[1] = y[1], x[2] = y[2], ... , x[r] = y[r] and x[r + 1] > y[r + 1]. Characters in such strings are 
compared like their ASCII codes.


Return the good string that lexicographically follows str, has the same length, and consists of only lowercase English letters. 
If such a string does not exist, return "Impossible" (without the quotes).

Create a C++ Function FindGoodString that will return a string denoting the lexicographically smallest good string larger than str. If such a string does 
not exist, return "Impossible"

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type:

An Integer denoting count
A String denoting str

Input Constraints:

The length of str should be at least 1 and at most 400,000 inclusive.
The value of count should be in the range [1, |str|] inclusive.
The string str consists only of lowercase English letters.

*/

#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>
#include <cassert>

bool IsValid(int index, int length, const std::vector<long long>& power, const std::vector<long long>& hash_val, const std::vector<long long>& rev_hash) {
    if (++index < length) return true;
    return ((rev_hash[index] - rev_hash[index - length] * power[length]) * power[index - length]) != (hash_val[index] - hash_val[index - length]);
}

bool GenerateString(int depth, int flag, int str_len, int count, const std::string& str, std::vector<char>& result, std::vector<long long>& power, std::vector<long long>& hash_val, std::vector<long long>& rev_hash) {
    if (depth == str_len) {
        return true;
    }
    for (result[depth] = (flag ? str[depth] : 'a'); result[depth] <= 'z'; result[depth]++) {
        hash_val[depth + 1] = hash_val[depth] + result[depth] * power[depth];
        rev_hash[depth + 1] = rev_hash[depth] * 1000000007 + result[depth];
        if (IsValid(depth, count, power, hash_val, rev_hash) && IsValid(depth, count + 1, power, hash_val, rev_hash) && GenerateString(depth + 1, flag && (result[depth] == str[depth]), str_len, count, str, result, power, hash_val, rev_hash))
            return true;
    }
    return false;
}

std::string Solve(int count, const std::string& str) {
  
    if (count <= 0 || count > static_cast<int>(str.length())) {
        throw std::invalid_argument("Count must be a positive integer less than or equal to the length of the string.");
    }
    
    if (str.length() > 400000) {
        throw std::invalid_argument("The length of the string must be no more than 4·10^5 characters.");
    }

    for (char character : str) {
        if (character < 'a' || character > 'z') {
            throw std::invalid_argument("The string must consist of lowercase English letters.");
        }
    }

    int str_len = static_cast<int>(str.length());
    std::vector<char> result(str_len + 1);
    std::vector<long long> power(str_len + 1), hash_val(str_len + 1), rev_hash(str_len + 1);

    std::string mutable_str = str;
    int index = str_len - 1;
    for (; index >= 0 && mutable_str[index] == 'z'; index--) 
        mutable_str[index] = 'a';
    
    if (index < 0) 
        return "Impossible";

    mutable_str[index]++;
    power[0] = 1;
    for (int i = 1; i <= str_len; i++) 
        power[i] = power[i - 1] * 1000000007;

    if (GenerateString(0, 1, str_len, count, mutable_str, result, power, hash_val, rev_hash))
        return std::string(result.begin(), result.begin() + str_len);
    
    return "Impossible";
}

#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>
#include <cassert>

int main() {
    
    return 0;
}
