/*
Link: https://codeforces.com/contest/1679/problem/F

Peterson is a mathematician, and his cognition of the world is so absolute as if he has been solving formal problems for hundreds of trillions of billions of years.
This problem is just like that!

Consider all non-negative integers from the interval [0, 10^digit_count). For convenience, we complement all numbers with leading zeros in such a way that each 
number from the given interval consists of exactly digit_count decimal digits.

You are given a set of pairs (ui, vi), where ui and vi are distinct decimal digits from 0 to 9.

Consider a number x consisting of digit_count digits. We will enumerate all digits from left to right and denote them as d1, d2, ..., dn. In one operation, you 
can swap digits di and di+1 if and only if there is a pair (uj, vj) in the set such that at least one of the following conditions is satisfied:

di = uj and di+1 = vj
di = vj and di+1 = uj

We will call the numbers x and y, consisting of digit_count digits, equivalent if the number x can be transformed into the number y using some number of operations 
described above. In particular, every number is considered equivalent to itself.

You are given an integer digit_count and a set of pair_count pairs of digits (ui, vi). You have to find the maximum integer k such that there exists a set of 
integers x1, x2, ..., xk (0 ≤ xi < 10^digit_count) such that for each 1 ≤ i < j ≤ k the number xi is not equivalent to the number xj.

Create a C++ function CountNonEquivalentNumbers that will return an integer denoting the maximum value k.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type: 

An integer denoting digit_count
A vector<vector<int>> denoting digit_pairs

Input Constraints:

The value of digit_count should be at least 1 and at most 50000 inclusive.
The value of pair_count should be at least 0 and at most 45 inclusive.
Each pair in digit_pairs consists of two digits (ui, vi) such that 0 ≤ ui < vi ≤ 9.
All described pairs in digit_pairs are pairwise distinct.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <cassert>
#include <set>


void AddModulo(int& target, int value) {
    target += value;
    int modulo = 998244353;
    if (target >= modulo) {
        target -= modulo;
    }
}

int CountNonEquivalentNumbers(int digit_count, std::vector<std::vector<int>>& digit_pairs) {
   
   int pair_count = digit_pairs.size();
  
     if (digit_count < 1 || digit_count > 50000 || pair_count < 0 || pair_count > 45) {
        throw std::invalid_argument("Invalid input size: Number of digits (digit_count) must be between 1 and 50000, and number of pairs (pair_count) must be between 0 and 45.");
    }

  
   int modulo = 998244353;
   int max_digits = 10;
   int max_states = 1 << max_digits; 
  
    std::vector<std::vector<int>> adjacency_matrix(max_digits, std::vector<int>(max_digits, 0));
    std::set<std::pair<int, int>> distinct_pairs;
  
    
  
    for (std::vector<int>& pair : digit_pairs) {
        int first_digit = pair[0], second_digit = pair[1];
        if (first_digit < 0 || first_digit >= 10 || second_digit < 0 || second_digit >= 10 || first_digit >= second_digit) {
            throw std::invalid_argument("Invalid digit pair: Digits must be between 0 and 9, and first digit must be less than second digit.");
        }
        if (!distinct_pairs.insert({first_digit, second_digit}).second) {
            throw std::invalid_argument("Pairs are not distinct.");
        }
        adjacency_matrix[first_digit][second_digit] = adjacency_matrix[second_digit][first_digit] = 1;
    }

    std::vector<std::vector<int>> transition(max_states, std::vector<int>(max_digits, 0));
    for (int state = 0; state < max_states; ++state) {
        for (int digit = 0; digit < max_digits; ++digit) {
            if (state >> digit & 1) {
                transition[state][digit] = -1;
                continue;
            }
            for (int neighbor_digit = 0; neighbor_digit < max_digits; ++neighbor_digit) {
                if (adjacency_matrix[digit][neighbor_digit]) {
                    if (neighbor_digit > digit || (state & (1 << neighbor_digit))) {
                        transition[state][digit] |= 1 << neighbor_digit;
                    }
                }
            }
        }
    }

    std::vector<std::vector<int>> dp_table(2, std::vector<int>(max_states, 0));
    dp_table[0][0] = 1;
    int toggle = 0;
    while (digit_count--) {
        for (int state = 0; state < max_states; ++state) {
            if (dp_table[toggle][state]) {
                for (int digit = 0; digit < max_digits; ++digit) {
                    int next_state = transition[state][digit];
                    if (next_state != -1) {
                        AddModulo(dp_table[toggle ^ 1][next_state], dp_table[toggle][state]);
                    }
                }
                dp_table[toggle][state] = 0;
            }
        }
        toggle ^= 1;
    }

    int result = 0;
    for (int state = 0; state < max_states; ++state) {
        AddModulo(result, dp_table[toggle][state]);
    }
    return result;
}

int main() {
    int digit_count, pair_count;
    std::cin >> digit_count >> pair_count;

    if (digit_count < 1 || digit_count > 50000 || pair_count < 0 || pair_count > 45) {
        throw std::invalid_argument("Invalid input size: Number of digits (n) must be between 1 and 50000, and number of pairs (m) must be between 0 and 45.");
    }

    std::vector<std::vector<int>> digit_pairs(pair_count, std::vector<int>(2));
    for (int i = 0; i < pair_count; ++i) {
        std::cin >> digit_pairs[i][0] >> digit_pairs[i][1];
        if (digit_pairs[i][0] < 0 || digit_pairs[i][0] >= 10 || digit_pairs[i][1] < 0 || digit_pairs[i][1] >= 10 || digit_pairs[i][0] >= digit_pairs[i][1]) {
            throw std::invalid_argument("Invalid digit pair: Digits must be between 0 and 9, and first digit must be less than second digit.");
        }
    }

    int result = SolveDigitPairs(digit_count, digit_pairs);
    std::cout << result << std::endl;

    return 0;
}

//TEST
//TEST_END

