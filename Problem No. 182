/*
Link: https://codeforces.com/contest/1673/problem/E

Brock has an ambiguous expression expr = a_1 ∧ a_2 ∧ a_3 ∧ ... ∧ a_n. The symbol ∧ can be replaced with either a power operation or an XOR operation to get an
unambiguous expression expr_prime.

The value of this expression expr_prime is determined according to the following rules:

All power operations are performed before any XOR operation. In other words, the power operation takes precedence over the XOR operation. For example, 4 XOR 6 
Power 2 = 4 ⊕ (6^2) = 4 ⊕ 36 = 32.
Consecutive powers are calculated from left to right. For example, 2 Power 3 Power 4 = (2^3)^4 = 8^4 = 4096.

You are given a vector elements of length num_elements and an integer target_sum. The vector vec_a is given by a_i = 2^b_i, and the expression expr is given by
expr = a_1 ∧ a_2 ∧ a_3 ∧ ... ∧ a_n. You need to find the XOR of the values of all possible unambiguous expressions expr_prime which can be obtained from expr 
and has at least target_sum ∧ symbols used as XOR operations. Since the answer can be very large, you need to find it modulo 2^(2^20). Since this number can also 
be very large, you need to print its binary representation without leading zeroes. If the answer is equal to 0, print 0.

Given an integer target_sum and a vector<int> elements of size num_elements return a binary string without leading zeroes denoting the answer to the problem. 
If the answer is equal to 0, print 0.

Create a C++ function CalculateExprValue that will return a string denoting the expected value.

Use appropriate error handling using the stdexcept library for the invalid test cases.

Input Type

An Integer denoting target_sum
vector<int> denoting elements

Input Constraints

The length of elements should be at least 1 and at most 2^20 inclusive.
Each value of elements should be in the range [1, 2^20) inclusive.
The values for target_sum should be in the range [0, num_elements) inclusive.

*/

#include <iostream>
#include <vector>
#include <stdexcept>
#include <sstream>
#include <cassert>

int ComputeResult(int num_elements, int target_sum) {
    if (target_sum <= 0) return num_elements == 0;
    if (num_elements < target_sum) return 0;
    return ((num_elements - 1) & (target_sum - 1)) == (target_sum - 1);
}

std::string CalculateExprValue(int target_sum, const std::vector<int>& elements) {
   
    int num_elements = elements.size();
    
    if (num_elements <= 0 || num_elements > 1048576) {
        throw std::invalid_argument("Invalid number of elements.");
    }
    if (target_sum < 0 || target_sum >= num_elements) {
        throw std::invalid_argument("Invalid target sum.");
    }
    for (int element : elements) {
        if (element < 1 || element >= 1048576) {
            throw std::invalid_argument("Invalid element value.");
        }
    }
    const int max_elements = (1 << 20) + 5;
    const int mask_value = (1 << 20) - 1;
    
    std::vector<int> results(max_elements, 0);
    int max_index = mask_value;

    for (int i = 0; i < num_elements; i++) {
        for (int j = i, current_sum = 0; j < num_elements; current_sum += elements[++j]) {
            if (current_sum >= 20 || (mask_value >> current_sum) < elements[i]) break;
            int extra_term = (i > 0) + (j < num_elements - 1);
            results[elements[i] << current_sum] ^= ComputeResult(num_elements - 1 - (j - i) - extra_term, target_sum - extra_term);
        }
    }

    while (max_index && !results[max_index]) --max_index;

    std::stringstream result_stream;
    while (~max_index) result_stream << results[max_index--];
    return result_stream.str();
}

#include <iostream>
#include <vector>
#include <stdexcept>
#include <sstream>
#include <cassert>

int main() {

    int num_elements, target_sum;
    std::cin >> num_elements >> target_sum;
    if (num_elements <= 0 || num_elements > 1048576) {
        throw std::invalid_argument("Invalid number of elements.");
    }
    if (target_sum < 0 || target_sum >= num_elements) {
        throw std::invalid_argument("Invalid target sum.");
    }

    std::vector<int> elements(num_elements);
    for (int i = 0; i < num_elements; i++) {
        std::cin >> elements[i];
        if (elements[i] < 1 || elements[i] >= 1048576) {
            throw std::invalid_argument("Invalid element value.");
        }
    }

    //TEST
    std::string result = ProcessData(target_sum, elements);
    std::cout << result;
    //TEST_END

    return 0;
}
