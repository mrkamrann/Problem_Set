/*

Jimmy the frog starts jumping from vertex 1 in an undirected tree consisting of len vertices numbered from 1 to len.
In one second, Jimmy jumps from his current vertex to another unvisited vertex if they are directly connected. Jimmy cannot jump back to a visited vertex. 
If Jimmy can jump to several vertices, he jumps randomly to one of them with the same probability. If Jimmy cannot jump to any unvisited vertex, he stays on the 
same vertex indefinitely.

The edges of the undirected tree are given in the array edges, where edges[i] = [node_a[i], node_b[i]] means there is an edge connecting the vertices node_a[i] and node_b[i].

Create a C++ function FrogPosition that will return the probability that after time number of seconds Jimmy is on the vertex target.
Answers within 10^-5 of the actual answer will be accepted.

Use appropriate Error Handling using the stdexcept library for the invalid test cases.

Input Type:

An Integer denoting len
vector<vector<int>> denoting the 2D vector edges
An Integer denoting time
An Integer denoting target

Input Constraints:

1.The number of vertices (len) should be at least 1 and at most 100 inclusive.
2.The number of edges should be exactly len - 1.
3.Each edge (edges[i]) should consist of exactly two vertices (node_a and node_b) in the range [1, len].
4.The number of seconds (time) should be at least 1 and at most 50 inclusive.
5.The target vertex (target) should be in the range [1, len].

*/



#include <vector>
#include <map>
#include <stdexcept>
#include <cassert>

    void Dfs(int target_node, int current_height, int current_node, std::vector<int> adj[], std::vector<int>& dfs_vis, int &node_height) {
        dfs_vis[current_node] = 1;
        if (current_node == target_node) {
            node_height = current_height;
            return;
        }
        for (int i = 0; i < adj[current_node].size(); ++i) {
            if (dfs_vis[adj[current_node][i]] == 0) {
                Dfs(target_node, current_height + 1, adj[current_node][i], adj, dfs_vis, node_height);
            }
        }
    }

    void ProbDfs(int current_node, int parent_node, std::vector<int> adj[], std::vector<int>& vis, std::vector<double>& dp_arr, std::map<int, int>& mpp) {
        vis[current_node] = 1;
        if (parent_node == -1) {
            dp_arr[current_node] = double(1);
        } else {
            dp_arr[current_node] = dp_arr[parent_node] * (1 / double(mpp[parent_node]));
        }
        for (int i = 0; i < adj[current_node].size(); ++i) {
            if (vis[adj[current_node][i]] == 0) {
                ProbDfs(adj[current_node][i], current_node, adj, vis, dp_arr, mpp);
            }
        }
    }

    double FrogPosition(int len, std::vector<std::vector<int>>& edges, int time, int target) {
      
        if (len < 1 || len > 100) {
            throw std::invalid_argument("Invalid number of vertices. Must be between 1 and 100 inclusive.");
        }
        if (edges.size() != len - 1) {
            throw std::invalid_argument("Invalid number of edges. Must be exactly len - 1.");
        }
        for (const std::vector<int> edge : edges) {
            if (edge.size() != 2 || edge[0] < 1 || edge[0] > len || edge[1] < 1 || edge[1] > len) {
                throw std::invalid_argument("Invalid edge format or vertex range.");
            }
        }
        if (time < 1 || time > 50) {
            throw std::invalid_argument("Invalid number of seconds. Must be between 1 and 50 inclusive.");
        }
        if (target < 1 || target > len) {
            throw std::invalid_argument("Invalid target vertex. Must be in the range [1, len].");
        }

      
        std::vector<int> adj[len + 1];
        for (int i = 0; i < edges.size(); ++i) {
            adj[edges[i][0]].push_back(edges[i][1]);
            adj[edges[i][1]].push_back(edges[i][0]);
        }

      
        std::vector<int> dfs_vis(len + 1, 0);
        int node_height;
        Dfs(target, 0, 1, adj, dfs_vis, node_height);

     
        if (node_height > time) return 0.0;

       
        bool more_nodes = false;
        for (int i = 0; i < adj[target].size(); ++i) {
            if (dfs_vis[adj[target][i]] == 0) {
                more_nodes = true;
                break;
            }
        }

      
        if (more_nodes && time > node_height) return 0.0;

   
        std::map<int, int> mpp;
       
        mpp[1] = adj[1].size();
        for (int i = 2; i <= len; ++i) {
            
            mpp[i] = adj[i].size() - 1;
        }

       
        std::vector<double> dp_arr(len + 1, 0);
        std::vector<int> vis(len + 1, 0);
        ProbDfs(1, -1, adj, vis, dp_arr, mpp);

        return dp_arr[target];
    }

int main(){
  return 0;
}

  
