/*
Link: https://leetcode.com/problems/split-the-array-to-make-coprime-products/

Julie is working on a problem involving an integer vector nums of length len. She needs to find a way to split the vector such that the product of the 
elements on the left side of the split and the product of the elements on the right side are coprime.

Here's the detailed task Julie needs to perform:

She has a 0-indexed integer vector nums with a length len.
A split at an index idx (where 0 ≤ idx ≤ len - 2) is considered valid if the product of the first idx + 1 elements and the product of the remaining 
elements in the vector are coprime.
Two values are said to be coprime if their greatest common divisor (gcd) is 1.
Julie needs to return the smallest index idx where the vector can be split validly. If no such valid split exists, she should return -1.

Create a C++ class Solution that will contain a function FindValidSplit that will return an integer denoting the smallest index at which the vector can be split validly or -1 
if no such split exists.

Use appropriate error handling using the stdexcept library for invalid test cases.

Input Type

A vector<int> denoting nums.

Input Constraints:

The length of nums should be at least 1 and at most 10^4 inclusive.
Each value in nums should be in the range [1, 10^6] inclusive.

*/

#include <vector>
#include <algorithm>
#include <stdexcept>
#include <cassert>
#include <iostream>

class Solution {
private:
  
    std::vector<int> smallest_prime_factor;
    std::vector<int> last_index;
    const int max_size = 1000001;
  

    void ComputeSmallestPrimeFactors() {
        smallest_prime_factor.resize(max_size);
        for (int i = 2; i < max_size; ++i) {
            smallest_prime_factor[i] = i;
        }
        for (int i = 2; i < max_size; i += 2) {
            smallest_prime_factor[i] = 2;
        }
        for (int i = 3; i * i < max_size; ++i) {
            if (smallest_prime_factor[i] == i) {
                for (int j = i * i; j < max_size; j += i) {
                    if (smallest_prime_factor[j] == j) {
                        smallest_prime_factor[j] = i;
                    }
                }
            }
        }
    }

    std::vector<int> ComputeUniquePrimeFactors(int value) {
        std::vector<int> factors;
        while (value != 1) {
            factors.push_back(smallest_prime_factor[value]);
            value /= smallest_prime_factor[value];
        }
        std::sort(factors.begin(), factors.end());
        factors.erase(std::unique(factors.begin(), factors.end()), factors.end());
        return factors;
    }

public:
    int FindValidSplit(std::vector<int>& nums) {
        int length = nums.size();

        if (length < 1 || length > 10000) {
            throw std::invalid_argument("The length of nums must be between 1 and 10000 inclusive.");
        }

        for (int value : nums) {
            if (value < 1 || value > 1000000) {
                throw std::invalid_argument("Each value in nums must be between 1 and 1000000 inclusive.");
            }
        }

        if (length == 1) {
            return -1;
        }

        ComputeSmallestPrimeFactors();
        last_index.resize(max_size, -1);

        for (int i = 0; i < length; ++i) {
            std::vector<int> primes = ComputeUniquePrimeFactors(nums[i]);
            for (int prime : primes) {
                last_index[prime] = i;
            }
        }

        int current_index = 0;
        int bound_index = 0;

        while (current_index <= bound_index) {
            std::vector<int> primes = ComputeUniquePrimeFactors(nums[current_index]);
            for (int prime : primes) {
                bound_index = std::max(bound_index, last_index[prime]);
            }
            current_index++;
        }

        if (bound_index <= length - 2) {
            return bound_index;
        }

        return -1;
    }
};

int main() {
    Solution solution;
   
    return 0;
}

